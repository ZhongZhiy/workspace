给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。 输入格式： 输入第一行给出一个正整数N（≤30），是二叉树中结点的个数。第二行给出其后序遍历序列。第三行给出其中序遍历序列。数字间以空格分隔。 
## 输出格式： 
在一行中输出该树的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。 

### 输入样例： 
>7 2 3 1 5 7 6 4 1 2 3 4 5 6 7 

### 输出样例： 
>4 1 6 3 5 7 2


好的，这是一个经典的算法问题：根据树的后序遍历和中序遍历序列重建该二叉树，并输出其层序遍历序列。

**核心思路**

1.  **重建二叉树:** 利用后序遍历和中序遍历的特性来唯一确定一棵二叉树的结构。
    *   **后序遍历 (Left, Right, Root):** 序列的最后一个元素一定是当前树（或子树）的根节点。
    *   **中序遍历 (Left, Root, Right):** 根节点的值会将序列分为两部分：左边是其左子树的所有节点，右边是其右子树的所有节点。
2.  **层序遍历:** 重建树结构后，使用广度优先搜索（BFS）进行层序遍历。

**重建二叉树的步骤 (递归)**

1.  **确定根节点:** 从后序遍历序列的最后一个元素找到当前树（或子树）的根节点的值。[[建树]]
2.  **划分中序序列:** 在中序遍历序列中找到这个根节点的值。该值左侧的序列是根节点的左子树的中序遍历，右侧的序列是根节点的右子树的中序遍历。
3.  **划分后序序列:** 根据左子树在中序遍历中的节点数量（假设为 `L`），可以确定后序遍历序列中哪些部分对应左子树和右子树。
    *   后序序列的前 `L` 个元素是左子树的后序遍历。
    *   接下来的 `N - 1 - L` 个元素（`N` 是当前子树的总节点数）是右子树的后序遍历。
    *   最后一个元素是根（已被使用）。
4.  **[[递归构建子树]]:**
    *   递归地使用左子树的后序序列和中序序列来构建左子树，并将返回的根节点连接到当前根节点的左孩子。
    *   递归地使用右子树的后序序列和中序序列来构建右子树，并将返回的根节点连接到当前根节点的右孩子。
5.  **递归基准情况:** 如果给定的后序或中序序列为空，表示这是一个空子树，返回 `nullptr`。

**优化:** 为了快速在中序遍历中找到根节点的位置，可以预先创建一个哈希表（`std::unordered_map`）来存储中序遍历中每个值及其对应的索引。

**层序遍历的步骤 (BFS)**

1.  **初始化:** 创建一个队列（`std::queue`），并将重建后的树的根节点入队。
2.  **循环:** 当队列不为空时：
    a.  **出队:** 从队列中取出一个节点。
    b.  **访问:** 将该节点的值记录到结果序列中。
    c.  **入队子节点:** 如果该节点有左孩子，将左孩子入队。
    d.  **入队子节点:** 如果该节点有右孩子，将右孩子入队。
3.  **完成:** 队列为空时，结果序列即为层序遍历序列。

**数据结构**

*   **树节点:** 定义一个结构体或类来表示二叉树的节点。
    ```c++
    struct TreeNode {
        int value;
        TreeNode *left;
        TreeNode *right;
        TreeNode(int val) : value(val), left(nullptr), right(nullptr) {}
    };
    ```
*   **存储遍历序列:** 使用 `std::vector<int>` 来存储输入的后序和中序序列。
*   **中序索引映射:** 使用 `std::unordered_map<int, int>` 存储中序序列值到索引的映射。
*   **层序遍历队列:** 使用 `std::queue<TreeNode*>`。

**C++ 代码实现**

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <stdexcept> // 用于 .at() 抛出的异常

// 二叉树节点定义
struct TreeNode {
    int value;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int val) : value(val), left(nullptr), right(nullptr) {}
    // 简单的析构函数（用于演示，竞赛中通常省略）
    // ~TreeNode() {
    //     delete left;
    //     delete right;
    // }
};

// 全局变量或传递给函数的参数来存储中序索引映射
std::unordered_map<int, int> inorder_index_map;

// 递归函数：根据后序和中序构建二叉树
// post_start, post_end 是后序序列当前考虑范围的起始和结束索引（闭区间）
// in_start, in_end 是中序序列当前考虑范围的起始和结束索引（闭区间）
TreeNode* buildTree(const std::vector<int>& postorder, int post_start, int post_end,
                   const std::vector<int>& inorder, int in_start, int in_end) {

    // 基准情况：序列为空
    if (post_start > post_end || in_start > in_end) {
        return nullptr;
    }

    // 1. 确定根节点值（后序的最后一个元素）
    int root_value = postorder[post_end];
    TreeNode* root = new TreeNode(root_value);

    // 如果只有一个节点
    if (post_start == post_end) {
        return root;
    }

    // 2. 在中序序列中找到根节点的位置
    int root_inorder_index = inorder_index_map.at(root_value); // 使用 .at() 查找

    // 3. 计算左子树的节点数量
    int left_subtree_size = root_inorder_index - in_start;

    // 4. 递归构建左子树
    // 左子树的后序范围：[post_start, post_start + left_subtree_size - 1]
    // 左子树的中序范围：[in_start, root_inorder_index - 1]
    root->left = buildTree(postorder, post_start, post_start + left_subtree_size - 1,
                          inorder, in_start, root_inorder_index - 1);

    // 5. 递归构建右子树
    // 右子树的后序范围：[post_start + left_subtree_size, post_end - 1] (注意 post_end - 1 是因为根节点用掉了 post_end)
    // 右子树的中序范围：[root_inorder_index + 1, in_end]
    root->right = buildTree(postorder, post_start + left_subtree_size, post_end - 1,
                           inorder, root_inorder_index + 1, in_end);

    return root;
}

int main() {
    int n;
    std::cin >> n;

    std::vector<int> postorder(n);
    std::vector<int> inorder(n);

    for (int i = 0; i < n; ++i) {
        std::cin >> postorder[i];
    }
    for (int i = 0; i < n; ++i) {
        std::cin >> inorder[i];
        inorder_index_map[inorder[i]] = i; // 构建中序索引映射
    }

    // 构建二叉树
    TreeNode* root = buildTree(postorder, 0, n - 1, inorder, 0, n - 1);

    // 层序遍历
    std::vector<int> level_order_result;
    if (root != nullptr) {
        std::queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            TreeNode* current = q.front();
            q.pop();
            level_order_result.push_back(current->value);

            if (current->left != nullptr) {
                q.push(current->left);
            }
            if (current->right != nullptr) {
                q.push(current->right);
            }
        }
    }

    // 输出层序遍历结果
    for (size_t i = 0; i < level_order_result.size(); ++i) {
        std::cout << level_order_result[i] << (i == level_order_result.size() - 1 ? "" : " ");
    }
    std::cout << std::endl;

    // 理论上需要释放 new 出来的内存，但在竞赛中通常省略
    // delete root; // 简单的析构函数可以递归删除

    return 0;
}
```

**代码解释:**

1.  `TreeNode` 结构体定义了二叉树节点。
2.  `inorder_index_map` 用于快速查找中序遍历中值对应的索引。
3.  `buildTree` 函数是核心的递归重建函数，它接收后序和中序序列以及当前处理的子序列的起止索引。
4.  在 `main` 函数中，读入数据，构建 `inorder_index_map`。
5.  调用 `buildTree` 开始重建过程，得到根节点 `root`。
6.  使用队列进行标准的层序遍历（BFS），将结果存入 `level_order_result`。
7.  按格式要求输出 `level_order_result`。
8.  内存管理：代码中使用了 `new` 创建节点，严格来说需要 `delete` 来释放内存以避免内存泄漏。但在算法竞赛的典型环境中，程序运行时间短，结束后操作系统会回收所有内存，因此通常省略显式的 `delete`。如果需要，可以实现一个递归的析构函数或使用智能指针。