# 1. Max Sum

[原题链接](https://vjudge.net/problem/HDU-1003/origin)
Given a sequence a[1],a[2],a[3]......a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.  

### Input

The first line of the input contains an integer T(1<=T<=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1<=N<=100000), then N integers followed(all the integers are between -1000 and 1000).  

### Output

For each test case, you should output two lines. The first line is "Case #:", # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.  

### Sample

| Inputcopy                                | Outputcopy                                |
| ---------------------------------------- | ----------------------------------------- |
| 2<br>5 6 -1 5 4 -7<br>7 0 6 -1 1 -6 7 -5 | Case 1:<br>14 1 4<br><br>Case 2:<br>7 1 6 |

## 题意
就是求连续子串的最大值

## 题解思路
维护一个区间和, 每次区间左端点`r`向左移动一位, 并且求得现在的区间和, 如果区间和小于0, 那么右端点就运动到左端点的下一位, 也就是`l = r + 1`, 跑完一遍就可以得到区间最大值

## 参考代码
```cpp

#include<bits/stdc++.h>
using namespace std;
#define i128 __int128
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define fi(x) for(int i = 1; i <= x; ++i)
#define fi0(x) for(int i = 0; i < x; ++i)
#define fj(n) for(int j = 1; j <= n; ++j)
#define fj0(n) for(int j = 0; j < n; ++j)
#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define PLEASE_AC return 0
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

const int N = 1e5 + 10;
int t;
int n, cases = 0;
int a[N];

void solve(){
	cin >> n;
	fi(n) cin >> a[i];
	int l = 1, r= 1, sum = 0, ansl = 1, ansr = 1, max_ans = -INT_MAX;
	while(r <= n) {
		sum += a[r];
		if(sum > max_ans){
			max_ans = max(max_ans, sum);
			ansl = l, ansr = r;
		}

		if(sum < 0){
			l = r + 1;
			sum = 0;
		} 
		r++;
	}
	cout << "Case "<< ++cases << ":\n";
	cout << max_ans << ' ' << ansl << ' '<< ansr << endl;
}

signed main() {
//	freopen("an", "r", stdin);
	caillo;

	cin >> t;
	while(t--) solve();

	PLEASE_AC;
}


```

# 2. P1440 求m区间内的最小值

## 题目描述

一个含有 $n$ 项的数列，求出每一项前的 $m$ 个数到它这个区间内的最小值。若前面的数不足 $m$ 项则从第 $1$ 个数开始，若前面没有数则输出 $0$。

## 输入格式

第一行两个整数，分别表示 $n$，$m$。

第二行，$n$ 个正整数，为所给定的数列 $a_i$。

## 输出格式

$n$ 行，每行一个整数，第 $i$ 个数为序列中 $a_i$ 之前 $m$ 个数的最小值。

## 输入输出样例 #1

### 输入 #1

```
6 2
7 8 1 4 3 2
```

### 输出 #1

```
0
7
7
1
1
3
```

## 说明/提示

对于 $100\%$ 的数据，保证 $1\le m\le n\le2\times10^6$，$1\le a_i\le3\times10^7$。

## 题解
只要维护一个单调队列, 队列头为区间最小值即可

## 代码
```cpp

#include<bits/stdc++.h>
using namespace std;
#define i128 __int128
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define fi(x) for(int i = 1; i <= x; ++i)
#define fi0(x) for(int i = 0; i < x; ++i)
#define fj(n) for(int j = 1; j <= n; ++j)
#define fj0(n) for(int j = 0; j < n; ++j)
#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define PLEASE_AC return 0
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

const int N = 2e6 + 10;
int a[N], ans[N];
int n, m;
struct Queue{
	int l = 1, r = 0;
	int v[N];
	void pop_front(){l++;}
	void pop_back(){r--;}
	void push(int x){v[++r] = x;}
	bool empty(){return r < l;}
	int size(){return r - l + 1;}
	int back(){return v[r];}
	int front(){return v[l];}
	void check(){
		for(int j = l; j <= r; ++j) cout << v[j] << ' ';
		cout << endl;
	}
}q;

signed main() {
//	freopen("an", "r", stdin);
	caillo;

	cin >> n >> m;
	fi(n) cin >> a[i];

	int t = 0;
	fi(n){
		if(i == 1) {
			ans[i] = 0;
			continue;
		}

		while(!q.empty() && a[q.back()] >= a[i-1]) q.pop_back();
		q.push(i-1);
		while(!q.empty() && i -1 - q.front() >= m) q.pop_front();
		ans[i] = a[q.front()];
	}

	fi(n) cout << ans[i] << '\n';


	PLEASE_AC;
}

```

---

title: Ornithology(逆序数)

date: 2025-10-03 19:38:59

categories: [算法, 逆序数]

tags: [补题]

---

  

# 3. 问题 H: Ornithology

文件提交：无需freopen 内存限制：128 MB 时间限制：1.000 S

## 题目描述

  

On the outskirts of the town, close to the farm, there stand two parallel power lines, separated by a narrow dirt road. The power lines were a favorite resting spot for a variety of birds.

Today, on this cool autumn morning, the lines are ﬁlled with a group of birds. On the ﬁrst line there are n consecutive positions for birds numbered 0, 1, . . . , n − 1. On the second power line there are also n positions numbered in the same manner.

Initially, every position of the ﬁrst line is occupied by some birds (possibly zero) and there are no birds on the second power line. Each bird has its desired position to ﬂy to on the second line. No two birds on the same position on the ﬁrst line share the same desired position.

At one moment, all the birds at once will decide to ﬂy to their desired positions. Every bird ﬂies along the straight line segment connecting its initial and desired position.

It can happen that some pairs of birds crash into each other during their ﬂight. This can happen when their corresponding line segments cross. We shall call such unordered pair of birds dangerous pair.
.
For example, if a bird on position 2 wants to go to position 1 and the bird on position 1 wants to go to position 2, their paths cross.

The birds will not collide if their paths have the same desired position (on the second line) or if they start from the same position (on the ﬁrst line). In other words a pair of birds with the same initial or desired positions is not considered a dangerous pair.

The task is very simple. Compute the number of dangerous pairs of birds.

## 输入

  

First line of input contains an integer n (1 ≤ n ≤ 2 · 105 ) representing the number of positions on both power lines.

Each of the next n lines describe the desired positions of the birds. The i-th line starts with an integer pi (0 ≤ pi ≤ n) representing the number of birds on position i.

Then, there are pi distinct numbers qi,1 , . . . , qi,pi (0 ≤ qi,j≤ n−1) representing the desired places of the pi birds.

It is guaranteed that the does not exceed 2 · 105 .

## 输出

  

Output exactly one line containing one integer – the number of dangerous pairs of birds.

### 样例输入

```

3

2 1 2

1 0

1 1

```

### 样例输出

```

3

```

  

## 题意

有两根平行的线, 一根线上有n给位置, 每个位置可能和对面某个位置连线, 一个位置可以和多个位置连线, 也可以没有连线, 问: 这些连线有多少个交点

  

## 题解思路

考虑到如果一条线起点`a`, 终点`b`, 那么起点大于`a`的点, 终点小于`b`就一定会和`ab`这条线相交, 那么我们按照起点排序, 然后所有的终点构成的序列的逆序数就是答案.

对于求逆序数, 使用树状数组维护每个数的频数, 每个数字的逆序数就是从后往前枚举每个数之前的频数之和

例如样例的z数列终点逆序数:

```

终点   1 2 0 1

逆序数 0 0 2 1

```

所以相加为3

## 参考代码

```cpp

  

#include<bits/stdc++.h>

using namespace std;

#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);

#define PLEASE_AC return 0

typedef long long ll;

typedef unsigned long long ull;

#define int long long

  

const int N = 2e5 + 10;

int n, idx = 0;

int a[N], tr[N];

  

int lowbit(int x){return x & -x;}

  

void add(int x){

  for(int pos = x; pos <= n; pos += lowbit(pos))

    tr[pos]++;

}

  

int query(int x) {

  int sum = 0;

  for(int pos = x - 1; pos; pos -= lowbit(pos))

    sum += tr[pos];

  return sum;

}

  

signed main() {

  // freopen("an", "r", stdin);

  caillo;

  

  cin >> n;

  for(int i = 1;i <= n; ++i) {

    int t; cin >> t;

    for(int j = 1;j <= t; ++j) {

      ++idx; cin >> a[idx];

      a[idx] += 2;  //由于需要查询前一个, 而且有零, 所以把所有的数有意2位, 这样就可以正常使用树状数组了

    }

    sort(a + 1 + idx - t, a + 1 + idx);  //对于每个起点的连线, 需要确保终点也是有序的

  }

  int ans = 0;

  for(int i = idx; i ; --i){

    ans += query(a[i]);

    add(a[i]);

  }

  cout << ans;

  

  PLEASE_AC;

}

```

---



# 4. 问题 F: Hamster

文件提交：无需freopen 内存限制：128 MB 时间限制：1.000 S

## 题目描述

  

The hamster lives in a rectangular enclosure with ﬂoor divided into square ﬁelds of the same size, forming a grid. In each ﬁeld, several larvae are dwelling. The hamster decided to walk around the enclosure, collect the larvae into his bowl, and bring them home for later culinary use. Additionally, he decided to place a trap for common starlings on each ﬁeld so that they would no longer ﬂy in and steal the larvae. The hamster starts in the northwest corner of the enclosure. From each visited ﬁeld, he collects the larvae and puts them in the bowl, places a trap on the ﬁeld, and moves to the next ﬁeld, which shares a side with the ﬁeld he is just leaving.

The hamster will ﬁnish his journey in the southeast corner of the enclosure. But there is a catch,the hamster cannot return to ﬁelds he has already visited, otherwise he would get caught in one of his own traps.

We know how many larvae are in each ﬁeld. Find out the maximum number of larvae the hamster can collect on his journey and avoid all traps.

## 输入

  

First line contains two numbers N, M (2 ≤ N, M ≤ 1000), the number of rows and the number of columns in the grid of ﬁelds in the hamster’s enclosure. Then follow N lines, each contains M numbers representing numbers of larvae in particular ﬁelds in the enclosure. Each line represents

one row in the grid. The northwest corner of the grid corresponds to the ﬁrst number in the ﬁrst of these lines, the southeast corner of the grid corresponds to the last number in the last of these lines.

The number of larvae on any ﬁeld is between 0 and 1000 inclusive.

## 输出

  

Output a single number, the maximum number of larvae the hamster can collect.

### 样例输入

  

【样例1】

```

2 2

1 2

3 4

```

【样例2】

```

3 4

2 2 4 0

1 3 1 0

2 5 3 1

```

### 样例输出

  

【样例1】

```

8

```

【样例2】

```

24

```

  

## 题意

给定`n`行`m`列的非负数, 取从左上角, 到右下角的路径上的所有的数的和, 要求不能重复经过同一个位置两次, 求最大取值

  
  

## 题解

显然, 取得尽可能多的位置最好.

我们把%N \times M$ 的网格像国际象棋一样黑白相间地涂色：左上角（西北角）是白色，相邻格子颜色总是不同。

从一个格子走到相邻的上/下/左/右格子时，颜色一定会发生切换（白→黑或黑→白）。

整条路是一条不重复格子的“简单路径”。

简单路径有一个重要性质：

  

如果起点和终点颜色不同，路径访问的格子数是偶数。

  

如果起点和终点颜色相同，路径访问的格子数是奇数。

原因：每走一步颜色就切一次，奇偶性决定了两端颜色是否相同。

  

我们的起点在左上角（白），终点在右下角。右下角的颜色是否与左上角相同，取决于 N 和 M：

  

右下角坐标（用 1 开始计数）是 (N, M)，它与左上角 (1,1) 的“曼哈顿距离”是 (N−1)+(M−1)。这一步数若是偶数，两端同色；若是奇数，两端异色。

  

等价地说：当 N+M 为偶数 时，两端同色；当 N+M 为奇数 时，两端异色。

总共有 N×M 个格子。我们希望“吃到”尽可能多的幼虫；因为每个格子的幼虫数都是非负，理想情况当然是把所有格子都走到。

  

若 至少有一个维度是奇数（也就是 N 或 M 有一个是奇数），就能设计出“蛇形”路线把所有格子都走到并且刚好到达右下角。

这时答案就是全体格子幼虫数之和。

  

若 N 和 M 都是偶数，事情就变了：

  

这时 N×M 是偶数，而我们前面说过此时起终点颜色相同（因为 N+M 偶数），意味着任何不重复路径访问的格子数必须是奇数。

  

但“所有格子”是偶数个，这与“访问格子数必须是奇数”冲突——不可能走完所有格子。

  

最多只能少走一个格子。而为了能从“白色起点到白色终点”，路径中白格数量会比黑格数量多 1，所以被迫少走（跳过）的那个格子一定是黑格（坐标 i+j 为奇数的格子，1-based 下）。

  

幼虫都是非负的，当然要把损失最小化：跳过幼虫数最小的那个黑格。

  

于是答案 = 所有格子之和 −（所有黑格中的最小值）。

  

## 参考代码

```cpp

  

#include<bits/stdc++.h>

using namespace std;

#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);

#define PLEASE_AC return 0

typedef long long ll;

typedef unsigned long long ull;

#define int long long

  

int n, m;

const int N = 1005;

int mp[N][N];

  
  

signed main() {

//  freopen("an", "r", stdin);

  caillo;

  

  cin >> n >> m;

  int min_b = INT_MAX, sum = 0;

  for(int i = 1;i <= n; ++i)

    for(int j = 1; j <= m; ++j){

      cin >> mp[i][j];

      sum += mp[i][j];

      if((i&1 && !(j&1)) || (!(i&1) && j&1)) min_b = min(min_b, mp[i][j]);

    }

  

  if(!(n&1) && !(m&1)) cout << sum - min_b;

  else cout << sum;

  

  PLEASE_AC;

}

```

# 5. 7986. 游戏


小 I 和小 J 又在玩游戏。

小 J 找来了一棵 n

个点的树。树上的每条边有开启和关闭两个状态，初始树上每条边都是开启的。

初始树上有一颗棋子放在 1

号节点。小 I 可以移动棋子，目标是将棋子移动到一个度数**恰好**为 1 的节点上；小 J 可以关闭树上的边，目标是阻止小 I 将棋子移动到度数恰好为 1

的节点上。

游戏分为若干轮，每轮有如下环节：

1. 小 I 任务判定：如果棋子在度数恰好为 1

2. 的节点上，小 I 获胜，否则进入第 2 步；
3. 小 J 行动：小 J 将一条目前开启的边，将这条边永久关闭，进入第 3 步，如果目前不存在开启的边则直接跳过行动进入第 3 步；
4. 小 I 行动：小 I 选择一条连接当前棋子所在节点且开启的边，将棋子移动到这条边的另一个节点上。如果没有这样的边，小 J 获胜，否则进入新的一轮，回到第 1 步。

小 J 想知道，如果小 I 和小 J 知道这棵树的形态且绝顶聪明，谁会获胜。

### 输入格式

从标准输入读入数据。

第一行一个整数 n(1≤n≤105)

表示树的节点数，接下来 n−1 行每行两个整数 u,v(1≤u,v≤n)

，表示树上的一条边。

### 输出格式

输出到标准输出。

如果小 I 获胜，输出 `You win, temporarily.`，否则输出 `Wasted.`。

### 样例

#### 输入

```
6
1 2
2 3
2 4
1 5
5 6
```

#### 输出

```
Wasted.
```

#### 解释

小 J 的策略如下：

- 小 J 将 (1,2)

关闭，这样小 I 只能移动到 5- ；
- 小 J 将 (5,6)
关闭，这样小 I 只得移动回 1- ；
- 小 J 将 (1,5)

- 关闭，于是小 I 无法移动。

### 样例

#### 输入

```
7
1 2
2 3
2 4
1 5
5 6
5 7
```

#### 输出

```
You win, temporarily.
```


# 6. 树上游戏
## 题意
在一棵树上, a在节点1, a要去到度为1的节点, 即叶子节点, 双方依次进行如下操作:
1. b选择一个边, 永久禁止a通过
2. a通过一个没有被禁止的边通过到达另一个节点
当a到叶子节点则win, 或者a没有边可走, 则lose

## 题解
这是个树上的博弈游戏, 我们可以分析可以举例得到, 到达叶子节点为win, 那么往上推, 叶子节点的父节点如果只邻接一个叶子节点, 那么这个叶子节点的边一定会被b禁止, 所以这种情况会lose, 但是如果这个节点邻接多个叶子节点, 那么这个节点也是win节点, 依次往上推, 如果这个节点邻接多个win节点, 那么这个节点也是win节点, 那么重复到节点1, 如果1是win节点是win节点, 那么这场游戏会win, 否则会lose
这个过程可以使用dfs实现, 访问节点1的子节点, 如果子节点再递归下去, 当返回的是win节点, 只用统计每个节点子win节点的个数, 最后就能确定节点1是不是win节点

## 参考代码
```cpp

#include<bits/stdc++.h>
using namespace std;
#define i128 __int128

#define fi(x) for(int i = 1; i <= x; ++i)
#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define PLEASE_AC return 0
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

const int N = 1e5 + 10;
vector<int> v[N];
int n;
bool sg[N];

bool dfs(int x, int fa){
	if(v[x].size() == 1) return true;

	int cnt = 0;
	for(auto c : v[x]){
		if(fa == c) continue;
		if(dfs(c, x)) cnt++;
	}

	return cnt >= 2;

}

signed main() {
//	freopen("an", "r", stdin);
	caillo;

	cin >> n;
	fi(n-1){
		int x, y; cin >> x >> y;
		v[x].push_back(y);
		v[y].push_back(x);
	}

	if(dfs(1, 0)) 
		cout << "You win, temporarily.";
	else 
		cout << "Wasted.";

	PLEASE_AC;
}

```

#  7. 问题 J: Prime Game

> 题目：给定序列 (a_1,\dots,a_n)（(n\le 10^6,\ a_i\le 10^6)）。  
> 设 ( \text{mul}(l,r)=\prod_{i=l}^{r} a_i)，( \text{fac}(l,r)) 为 (\text{mul}(l,r)) 的**不同质因子**个数。  
> 求 (\displaystyle \sum_{i=1}^{n}\sum_{j=i}^{n} \text{fac}(i,j))。

---
#### 输入

The first line contains one integer n (1 ≤ n ≤ 106 ) — the length of the sequence.  
The second line contains n integers ai (1 ≤ i ≤ n, 1 ≤ ai ≤ 106 ) — the sequence.  

#### 输出

Print the answer to the equation.

#### 样例输入

```
10
99 62 10 47 53 9 83 33 15 24
```

#### 样例输出

```
248
```


## 题解

##  核心转化（贡献法 / 分解到质数）

对每个质数 (p) 单独计数它在多少个子数组中**出现过**（即区间里至少有一个元素被 (p) 整除）。  
设 (C_p) 为这样的子数组个数，则  
[  
\sum_{l\le r}\text{fac}(l,r) ;=; \sum_{\text{质数 }p} C_p .  
]  
原因：每个子数组的“不同质因子个数”就是对**所有质数**做 0/1 贡献的求和；交换求和顺序即可（典型的贡献法）。

于是问题变为：**对每个出现过的质数 (p)**，统计“包含至少一个被 (p) 整除位置”的子数组数。

设所有长度为 (n) 的子数组总数为 (T=\frac{n(n+1)}{2})。  
把数组中“被 (p) 整除的位置”作为障碍点，数组被这些点切成若干**不含 (p)** 的连续空段（gap）。  
若某个 gap 的长度为 (g)，那么**完全落在这个 gap 内**的子数组都不含 (p)，共有 (\frac{g(g+1)}{2}) 个。  
把所有 gap 的这类子数组数相加记为 (N_p)。则  
[  
C_p ;=; T - N_p .  
]

> 小结：**只需求每个质数的“避开 (p) 的子数组个数”**，用总数减掉即可。

---

##  算法步骤（满足 (10^6) 规模）

1. **线性筛 / SPF（最小质因子）**到 (10^6)：支持 (O(\log a_i)) 分解每个 (a_i) 的**不同质因子**。
    
2. 扫描数组第 (i) 个元素，分解出其**不同**质因子集合 ({p})：
    
    - 对每个出现的 (p)，用 `last[p]` 记录上次出现 (p) 的位置（初始为 0，表示在 1 之前）。
        
    - 当前位置为 (i)，则**上一个出现位置到当前的 gap 长度**为 `gap = i - last[p] - 1`。把 (\frac{gap(gap+1)}{2}) 累加进 `noP[p]`（即 (N_p) 的部分和），然后更新 `last[p]=i`。
        
    - 第一次遇到某个 (p) 时，`gap = i-1`，正好统计左端头的空段。
        
    - 用一个 `visitedPrimes` 记录所有出现过的质数，便于收尾。
        
3. 扫描完所有位置后，对每个出现过的 (p) 再补上**尾端 gap**：  
    `gap_tail = n - last[p]`，把 (\frac{gap_tail(gap_tail+1)}{2}) 加到 `noP[p]`。
    
4. 令 (T=\frac{n(n+1)}{2})。答案为  
    [  
    \sum_{p\ \text{出现过}} \bigl( T - \text{noP}[p] \bigr).  
    ]
    
5. 全程使用 64 位整型保存答案与组合数量。
    

## 参考代码
```cpp

#include<bits/stdc++.h>
using namespace std;
#define i128 __int128
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define fi(x) for(int i = 1; i <= x; ++i)
#define fi0(x) for(int i = 0; i < x; ++i)
#define fj(n) for(int j = 1; j <= n; ++j)
#define fj0(n) for(int j = 0; j < n; ++j)
#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define PLEASE_AC return 0
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

constexpr int N = 1e6 + 10;
int spf[N];
void pre_spf(){  //预处理, 用ai氏筛找spf
	for(int i = 2;i < N; ++i){
		if(!spf[i]){
			spf[i] = i;
			if(i * i > N) continue;
			for(int j = i * i; j < N; j += i){
				if(!spf[j]) spf[j] = i;
			}
		}
	}

	spf[1] = 1;
}

int last[N], seen[N], nop[N];  //last[p]是p上次出现的位置, seen[p]是记录p是不是第一次出现, nop[p]是记录不包含p的区间个数
signed main() {
//	freopen("an", "r", stdin);
	caillo;

	pre_spf();

	int n; cin >> n;

	vector<int> visited;  //记录所有出现的素数, 用于计算最后一段gap
	for(int i = 1;i <= n; ++i){
		int x; cin >> x;
		if(x == 1) continue;
		vector<int> primes;  //记录这数包含的素数
		while(x > 1){  //找素数
			int p = spf[x];
			primes.push_back(p);
			while(x % p == 0) x /= p;  //清除这个数的p因子
		}

		for(auto p : primes){  //计算从上一个位置到这位置的p的gap
			if(!seen[p]){seen[p] = 1;visited.push_back(p);}
			int gap = i - last[p] - 1;
			if(gap > 0) nop[p] += gap * (gap + 1) / 2;
			last[p] = i;
		}
	}

	for(auto p : visited){  //计算最后的gap
		int gap = n - last[p];
		if(gap > 0) nop[p] += gap * (gap + 1) / 2;
	}

	int t = n * (n + 1) >> 1;
	int ans = 0;
	for(auto p : visited) ans += (t - nop[p]);

	cout << ans << endl;

	PLEASE_AC;
}
	
```


# 8. D. Destruction of the Dandelion Fields

## 题目
Farmer John has a lawnmower, initially turned off. He also has $n$ fields, with the $i$\-th field having $a_i$ dandelions. He will visit all the fields in any order he wants, and each field **exactly once**.

FJ's lawnmower seems to have a mind of its own. Right before visiting a field, it checks if the field has an even or odd number of dandelions. If it has an odd number, then the lawnmower toggles its state (if it is off, it turns on; if it is on, it turns off). Then, if the lawnmower is on, it will cut all dandelions in that field. Otherwise, if the lawnmower is off, then FJ will simply visit the field and cut no dandelions.

If FJ visits the $n$ fields in optimal order, what is the maximum total number of dandelions he can cut?

## 输入
**Input**

The first line contains an integer $t$ ($1 \leq t \leq 10^4$) — the number of test cases.

The first line contains an integer $n$ ($1 \leq n \leq 2 \cdot 10^5$) — the number of fields.

The following line contains $n$ space-separated integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 10^9$) — the number of dandelions in each field.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

## 输出
**Output**

For each test case, output an integer on a new line: maximum dandelions FJ can cut if he visits all $n$ fields in optimal order.

## 样例
### 输入
```
3
3
2 4 6
4
4 2 1 6
4
1000000000 999999999 1000000000 999999999

```

### 输出
```
0
13
2999999999

```
### 提示
**Note**

For the first test case, since there is no field with an odd number of dandelions, FJ can never turn his lawnmower on. Since his lawnmower is always off, he can never cut any dandelions, so the answer is $0$.

For the second test case, FJ can visit the third field first; then his lawnmower will turn on. Then he can visit the other fields in any order. Since his lawnmower is always on, dandelions in every field can be cut.

For the third test case, FJ can visit the fields in the following order: field $2$, field $1$, field $3$, then field $4$.

## 题意
一组草坪, 每个地方有一定数量的草, 你有除草器, 当遇到奇数的草时, 除草器的开关就会切换, 你可以按照任意顺序除草, 你最多能除草多少?每个草坪只能走一次

## 分析
1. 首先, 没有奇数的话, 除草器就不会打开, 答案为0
2. 如果有奇数, 那么就可以把偶数全部取走
3. 但是如果遇到奇数, 就不能取了, 然后可以到下一个奇数区打开
4. 所有, 所有奇数区, 有一半是可以取的, 因此, 奇数排个序, 取较大的一半就可以了

### 参考代码
```cpp
#include <bits/stdc++.h>

using namespace std;

using int64 = long long;

  

int main() {

    ios::sync_with_stdio(false);

    cin.tie(nullptr);

  

    int T;

    if(!(cin >> T)) return 0;

    while (T--) {

        int n; cin >> n;

        vector<int64> odds;

        long long sum_even = 0;

        for (int i = 0; i < n; ++i) {

            long long x; cin >> x;

            if (x & 1) odds.push_back(x);

            else sum_even += x;

        }

  

        if (odds.empty()) {

            cout << 0 << '\n';

            continue;

        }

  

        sort(odds.begin(), odds.end(), greater<int64>());

        int k = (int) ( (odds.size() + 1) / 2 ); // 取最大的 ceil(m/2) 个

        long long pick_odds = 0;

        for (int i = 0; i < k; ++i) pick_odds += odds[i];

  

        cout << (sum_even + pick_odds) << '\n';

    }

    return 0;

}
```

# 10. B. Deck of Cards

## 题目
Monocarp has a deck of cards numbered from $1$ to $n$. Initially, the cards are arranged from smallest to largest, with $1$ on top and $n$ at the bottom.

Monocarp performed $k$ actions on the deck. Each action was one of three types:

-   remove the top card;
-   remove the bottom card;
-   remove either the top or bottom card.

Your task is to determine the fate of each card: whether it remains in the deck, has been removed, or might be both.

## 输入
**Input**

The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.

The first line of each test case contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$).

The second line contains a string $s$ of length $k$, consisting of characters 0, 1, and/or {2}. This string describes Monocarp's actions. If the $i$\-th character is 0, Monocarp removes the top card on the $i$\-th action. If it's 1, he removes the bottom card. If it's 2, either the top or bottom card can be removed.

Additional constraint on the input: the sum of $n$ over all test cases doesn't exceed $2 \cdot 10^5$.
## 输出
**Output**

For each test case, print a string consisting of $n$ characters. The $i$\-th character should be + (plus sign) if the $i$\-th card is still in the deck, \- (minus sign) if it has been removed, or ? (question mark) if its state is unknown.

## 样例
### 输入
```
4
4 2
01
3 2
22
1 1
2
7 5
01201

```
### 输出
```
-++-
???
-
--?+?--
```

## 题意
从1到n的从小到大叠在一起的一副牌, 进行如下k次操作
- 操作0, 把最底下的牌抽出
- 操作1 把最顶上的牌抽出
- 操作3, 把最底下或者最顶上的牌抽出
输出操作后的牌

## 题解
1. 主要考虑操作2, 操作0, 和1都是确定的
2. 如果有操作2, 那么最低和最顶上的牌都不能确定
3. 操作2之后有操作1或0的话, 不确定的牌就会前移, 如样例4
4. 还需要考虑样例3的情况, 如果不确定的牌等于操作2的个数, 那么意味着这部分牌都被抽出了

### 参考代码
```cpp
  

#include<bits/stdc++.h>

using namespace std;

#define i128 __int128

#define de(x) cout << (#x) << " = " << (x) << endl;

#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;

#define endl '\n'

#define fi(x) for(int i = 1; i <= x; ++i)

#define fi0(x) for(int i = 0; i < x; ++i)

#define fj(n) for(int j = 1; j <= n; ++j)

#define fj0(n) for(int j = 0; j < n; ++j)

#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);

#define PLEASE_AC return 0

#define startime auto start = chrono::high_resolution_clock::now();

#define endtime auto end = chrono::high_resolution_clock::now();

#define runningtime cout << "running time: " << chrono::duration_cast<chrono::milliseconds>(end - start).count()<<" ms\n";

typedef long long ll;

typedef unsigned long long ull;

#define int long long

  

int t, n, k;

const int N = 2e5 + 10;

int a[N];

void solve(){

    cin >> n >> k;

    string s; cin >> s;

    memset(a, 0, sizeof(a));

  

    int l = 1, r = n, hl = 1, hr = n;  //l 和r是确定被抽出的牌的下标, hl和hr是不确定的下标

    int cnt  = 0;

    for(auto c : s){

        if(c == '0'){

            a[l++] = 1;

            hl++;

        }else if(c == '1'){

            a[r--] = 1;

            hr--;

        }else {

            cnt++;

            hl++;

            hr--;

        }

    }

    int ccnt = 0;

    for(int i = 1;i <= n; ++i){  //计算有多少个不确定的

        if(a[i] == 0 && (i < hl || i > hr))

            ccnt++;
    }
    
    char ch = '?';
    if(ccnt == cnt) ch = '-';

    for(int i = 1;i <= n; ++i){

        if(a[i] == 1)

            cout << '-';

        else if(i < hl || i > hr)

                cout << ch;

        else

            cout << '+';

    }

    cout << endl;

}

  
  

signed main() {

//  freopen("an", "r", stdin);

    caillo;

  

    cin >> t;

    while(t--) solve();

  

    PLEASE_AC;

}
```


# 11. B. Discounts

## 题目
You want to buy $n$ products with prices $a_1, a_2, \ldots, a_n$. You can either:

-   buy product $i$ individually, paying $a_i$ coins, or
-   use a discount voucher to buy it as part of a group purchase.

You have $k$ discount vouchers with values $b_1, b_2, \ldots, b_k$. A voucher of value $x$ allows you to select exactly $x$ products and pay only for the $x - 1$ most expensive ones, as such, you can consider that the cheapest product in the group is free. Each product can be included in **at most one** discount group, even if it is not the free one. Also, any single voucher can be used at most one single time.

What is the **minimum total cost** required to purchase all $n$ products?
## 输入
**Input**

Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.

The first line contains two integers $n$ and $k$ ($1 \le n, k \le 2 \cdot 10^5$) —the number of products and the number of available discount vouchers.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^9$) — the prices of the products.

The third line contains $k$ integers $b_1, b_2, \ldots, b_k$ ($1 \le b_i \le n$) — the values of the discount vouchers.

It is guaranteed that the sum of $n$ across all test cases does not exceed $2 \cdot 10^5$, and the sum of $k$ across all test cases does not exceed $2 \cdot 10^5$.
## 输出
**Output**

Print $t$ lines. The $i$\-th line should contain the answer for the $i$\-th test case — the minimum total cost required to purchase all products in that test case.
## 样例
### 输入
```
5
5 3
18 3 7 2 9
3 1 1
6 1
1 2 6 3 3 4
5
2 3
1 1
2 2 2
1 1
10
1
5 3
99 99 999 999 123
2 1 4

```
### 输出
```
10
17
1
0
1197

```
## 提示
**Note**

In the first test case, you can apply the first discount to products 2, 3, and 4. You will pay for the two most expensive ones (3 and 7 coins) and get the cheapest one for free, resulting in a cost of $3 + 7 = 10$ coins. Then, apply the second and third discounts to products 1 and 5, getting both for free. The total cost is $10$ coins.

In the second test case, you can use the single discount on products 2, 3, 4, 5, and 6. Among them, the cheapest is product 2 (costing 2 coins), which you get for free. You pay for the remaining products: $1 + 6 + 3 + 3 + 4 = 17$ coins in total.

In the third test case, only one discount is available. You can use it on both products, getting the cheaper one for free and paying $1$ coin for the other.
## 题意

您想购买价格为 a1,a2,…,an 的 n件产品。您可以选择:
- 单独购买产品 i，支付 ai个金币，或者
- 使用折扣券作为团购的一部分购买。

您有价值 b1,b2,…,bk的 k 折扣券。价值 x 的折扣券允许您选择 x 种产品，只需支付 x−1种最贵的产品，因此，您可以认为团购中最便宜的产品是免费的。每个产品最多可以包含在**个**折扣组中，即使它不是免费的。此外，任何一张优惠券最多只能使用一次。

购买所有 n产品所需的**最低总费用是多少？**

## 题解
1. 使用贪心的思维, 最少的折扣券应该用在最贵的商品上, 这样才能让免费的商品最贵
2. 因此, 对商品逆序排, 对团购券正序排
3. 然后模拟就行了
### 参考代码
```cpp
  

#include<bits/stdc++.h>

using namespace std;

#define i128 __int128

#define de(x) cout << (#x) << " = " << (x) << endl;

#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;

#define endl '\n'

#define fi(x) for(int i = 1; i <= x; ++i)

#define fi0(x) for(int i = 0; i < x; ++i)

#define fj(n) for(int j = 1; j <= n; ++j)

#define fj0(n) for(int j = 0; j < n; ++j)

#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);

#define PLEASE_AC return 0

#define startime auto start = chrono::high_resolution_clock::now();

#define endtime auto end = chrono::high_resolution_clock::now();

#define runningtime cout << "running time: " << chrono::duration_cast<chrono::milliseconds>(end - start).count()<<" ms\n";

typedef long long ll;

typedef unsigned long long ull;

#define int long long

  

int t, n, k;

const int N = 2e5 + 10;

int a[N], b[N];

void solve(){

    cin >> n >> k;

    // de2(n, k);

    fi(n) cin >> a[i];

    fi(k) cin >> b[i];

    // return;

    sort(b+1, b+1+k);

    sort(a+1, a+1+n, greater<int>());

  

    int csm = 0, si = 0;

    int i = 1, j = 1;

    while(i <= n){

        if(j <= k && b[j] <= n - i + 1){

            while(--b[j]){

                csm+= a[i++];

            }

            i++;

            j++;

        }else{

            csm += a[i++];

        }

    }

  

    cout << csm << endl;

}

  

signed main() {

//  freopen("an", "r", stdin);

    caillo;

  

    cin >> t;

    while(t--) solve();

  

    PLEASE_AC;

}
```

# 12. B. Move to the End
## 题目
You are given an array $a$ consisting of $n$ integers.

For every integer $k$ from $1$ to $n$, you have to do the following:

1.  choose an arbitrary element of $a$ and move it to the right end of the array (you can choose the last element, then the array won't change);
2.  print the sum of $k$ last elements of $a$;
3.  move the element you've chosen on the first step to its original position (restore the original array $a$).

For every $k$, you choose the element which you move so that the value you print is **the maximum possible**.

Calculate the value you print for every $k$.
## 输入
**Input**

The first line contains one integer $t$ ($1 \le t \le 10^4$) — the number of test cases.

Each test case consists of two lines:

-   the first line contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$);
-   the second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^9$).

Additional constraint on the input: the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.
## 输出
**Output**

For each test case, print $n$ integers. The $i$\-th of these integers should be equal to the maximum value you can print if $k=i$.

## 样例
### 输入
```
4
7
13 5 10 14 8 15 13
6
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
1
42
2
7 5
```
### 输出
```
4
7
13 5 10 14 8 15 13
6
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
1
42
2
7 5
```

## 提示
**Note**

Let's consider the first test case from the statement:

-   when $k = 1$, you can move the $6$\-th element to the end, the array becomes $[13, 5, 10, 14, 8, 13, 15]$, and the value you print is $15$;
-   when $k = 2$, you can move the $6$\-th element to the end, the array becomes $[13, 5, 10, 14, 8, 13, 15]$, and the value you print is $13 + 15 = 28$;
-   when $k = 3$, you can move the $4$\-th element to the end, the array becomes $[13, 5, 10, 8, 15, 13, 14]$, and the value you print is $15 + 13 + 14 = 42$;
-   when $k = 4$, you can move the $5$\-th element to the end, the array becomes $[13, 5, 10, 14, 15, 13, 8]$, and the value you print is $14 + 15 + 13 + 8 = 50$;
-   when $k = 5$, you can move the $1$\-st element to the end, the array becomes $[5, 10, 14, 8, 15, 13, 13]$, and the value you print is $14 + 8 + 15 + 13 + 13 = 63$;
-   when $k = 6$, you can move the $1$\-st element to the end, the array becomes $[5, 10, 14, 8, 15, 13, 13]$, and the value you print is $10 + 14 + 8 + 15 + 13 + 13 = 73$;
-   when $k = 7$, you can move the $6$\-th element to the end, the array becomes $[13, 5, 10, 14, 8, 13, 15]$, and the value you print is $13 + 5 + 10 + 14 + 8 + 13 + 15 = 78$.

## 题解
考虑到, 每次只会移动一个数字到最后, 同时倒数第k个会被挤出求和, 所以考虑只要比较k之前的最大值和倒数第k个数, 这样就可以求得
求前几个数中的最大值, 可以用ST表维护, 预处理时间复杂度为O(logn)

## 参考代码
```cpp
  

#include<bits/stdc++.h>

using namespace std;

#define i128 __int128

#define de(x) cout << (#x) << " = " << (x) << endl;

#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;

#define endl '\n'

#define fi(x) for(int i = 1; i <= x; ++i)

#define fi0(x) for(int i = 0; i < x; ++i)

#define fj(n) for(int j = 1; j <= n; ++j)

#define fj0(n) for(int j = 0; j < n; ++j)

#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);

#define PLEASE_AC return 0

#define startime auto start = chrono::high_resolution_clock::now();

#define endtime auto end = chrono::high_resolution_clock::now();

#define runningtime cout << "running time: " << chrono::duration_cast<chrono::milliseconds>(end - start).count()<<" ms\n";

typedef long long ll;

typedef unsigned long long ull;

#define int long long

  

const int N = 2e5 + 10;

int t, n;

int a[N], head[N];

int f[N][21], lg[N];

  

void pre(){

    for(int i = 2;i <= n; ++i)

        lg[i] = lg[i/2] + 1;

  

    for(int i = 1;i <= n; ++i)

        cin >> f[i][0];

  

    for(int i = 1;i <= 20; ++i)

        for(int j = 1;j + (1 << i) - 1 <= n; ++j)

            f[j][i] = max(f[j][i-1], f[j+(1<<(i-1))][i-1]);

}

  

int find(int l, int r){

    int s = lg[r - l + 1];

    return max(f[l][s], f[r-(1<<s) + 1][s]);

}

  
  

void solve(){

    cin >> n;

    pre();

    fi(n) head[i] = head[i-1] + f[i][0];

  

    fi(n){

        int mx = find(1, n - i);

        int sm = head[n] - head[n - i + 1];

        cout << max(mx, f[n-i+1][0]) + sm << ' ';

    }

    cout<< endl;

}

  

signed main() {

//  freopen("an", "r", stdin);

    caillo;

  

    cin >> t;

    while(t--) solve();

  
  

    PLEASE_AC;

}
```

# 13. C. Combination Lock

## 题目
At the IT Campus "NEIMARK", there are several top-secret rooms where problems for major programming competitions are developed. To enter one of these rooms, you must unlock a circular lock by selecting the correct code. This code is updated every day.

Today's code is a permutation$^{\text{∗}}$ of the numbers from $1$ to $n$, with the property that in every cyclic shift$^{\text{†}}$ of it, there is exactly one fixed point. That is, in every cyclic shift, there exists exactly one element whose value is equal to its position in the permutation.

Output any valid permutation that satisfies this condition. Keep in mind that a valid permutation might not exist, then output $-1$.

$^{\text{∗}}$A permutation is defined as a sequence of length $n$ consisting of integers from $1$ to $n$, where each number appears exactly once. For example, (2 1 3), (1), (4 3 1 2) are permutations; (1 2 2), (3), (1 3 2 5) are not.

$^{\text{†}}$A cyclic shift of an array is obtained by moving the last element to the beginning of the array. A permutation of length $n$ has exactly $n$ cyclic shifts.
## 输入
**Input**

Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 500$). The description of the test cases follows.

A single line of each test case contains a single integer $n$ ($1 \leq n \leq 2 \cdot 10^5$).

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

## 输出
**Output**

For each test case, output the desired permutation. If multiple solutions exist, output any one of them. If no suitable permutations exist, output $-1$.

## 样例
### 输入
```
3
4
5
3
```
### 输出
```
-1
4 1 3 5 2
1 3 2
```

## 题意
给定n, 求一个n的排列, 使得排列的0到n-1次循环移位都有某个数字位于对应的位置

## 题解


假设经过 (k) 次循环位移后，元素 $p_i$ 被移动到了位置 $(i + k) \bmod n$。要使这个点成为不动点（即该位置上的数字仍是原本的数字），必须满足：

$$
(i + k) \bmod n = p_i  
$$

我们假设排列 (p) 是从 0 开始的形式：  
$$
p = [0, 1, 2, \ldots, n - 1]  
$$

由上述等式我们可以得到：  
$$
k \equiv p_i - i \pmod{n}  
$$

为了使**任意循环位移都存在不动点**，就必须能够从 $p_i - i \pmod{n}$ 得到从 (0) 到 (n - 1) 的所有可能的 (k)。

对此，我们对所有可能的 $k = p_i - i \pmod{n}$ 求和：

左边是：  
$$
\sum_{k=0}^{n-1} k = \frac{n(n-1)}{2}  
$$

右边是：  
$$
\sum_{i=0}^{n-1}(p_i - i) = \sum_{i=0}^{n-1}p_i - \sum_{i=0}^{n-1}i  
$$

由于 (p) 是一个从 (0) 到 (n-1) 的排列，因此两边的和是相等的，所以：  
$$  
\sum p_i = \sum i \Rightarrow \sum (p_i - i) = 0  
$$

因此，要构造这样的排列，必须满足：  
$$  
\frac{n(n - 1)}{2} \equiv 0 \pmod{n}  
$$

当 (n) 为偶数时，上式不成立，因此答案为 (-1)。  
当 (n) 为奇数时，上式成立。其中一种满足条件的排列是：  
$$  
p = [n-1, n-2, \ldots, 2, 1, 0]  
$$

时间复杂度为 (O(n))。

## 参考代码
```cpp

#include<bits/stdc++.h>
using namespace std;
#define i128 __int128
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define fi(x) for(int i = 1; i <= x; ++i)
#define fi0(x) for(int i = 0; i < x; ++i)
#define fj(n) for(int j = 1; j <= n; ++j)
#define fj0(n) for(int j = 0; j < n; ++j)
#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define PLEASE_AC return 0
#define startime auto start = chrono::high_resolution_clock::now();
#define endtime auto end = chrono::high_resolution_clock::now();
#define runningtime cout << "running time: " << chrono::duration_cast<chrono::milliseconds>(end - start).count()<<" ms\n";
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

int t, n;
const int N = 55;
int mp[N][N];
void solve(){
	cin >> n;
	if(n&1){
		for(int i = n;i > 0;i--) 
			cout << i << ' ';
	}else 
		cout << -1;
	cout << endl;
}

signed main() {
//	freopen("an", "r", stdin);
	caillo;

	cin >> t;
	while(t--) solve();

	PLEASE_AC;
}

```


# 14. B. Crafting

## 题目
| As you'd expect, Florida is home to many bizarre magical forces, and Florida Man seeks to tame them. |
|  ---  |

There are $n$ different types of magical materials, numbered from $1$ to $n$. Initially, you have $a_i$ units of material $i$ for each $i$ from $1$ to $n$. You are allowed to perform the following operation:

-   Select a material $i$ (where $1\le i\le n$). Then, spend $1$ unit of **every** other material $j$ (in other words, $j\neq i$) to gain $1$ unit of material $i$. More formally, after selecting material $i$, update array $a$ as follows: $a_i := a_i + 1$, and $a_j := a_j - 1$ for all $j$ where $j\neq i$ and $1\le j\le n$. Note that all $a_j$ must remain non-negative, i.e. you cannot spend resources you do not have.

You are trying to craft an artifact using these materials. To successfully craft the artifact, you must have at least $b_i$ units of material $i$ for each $i$ from $1$ to $n$. Determine if it is possible to craft the artifact by performing the operation any number of times (including zero).

## 输入
**Input**

Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($2\le n\le 2\cdot 10^5$) — the number of types of materials.

The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i\le 10^9$) — the amount of each material $i$ that you currently hold.

The third line of each test case contains $n$ integers $b_1, b_2, \ldots, b_n$ ($0 \le b_i\le 10^9$) — the amount of each material $i$ needed to produce the artifact.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.
## 输出
**Output**

For each test case, print a single line containing either "YES" or "NO", representing whether or not the artifact can be crafted.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

## 样例
### 输入
```
3
4
0 5 5 1
1 4 4 0
3
1 1 3
2 2 1
2
1 10
3 3

```
### 输出
```
YES
NO
YES

```

## Note
**Note**

In the first test case, perform an operation on material $1$. After doing so, we will have exactly the required resources: $1$ unit of material $1$, and $4$ units each of materials $2$ and $3$.

In the second test case, it can be shown that no matter how the operations are performed, it is impossible to craft the artifact.

In the third test case, we can perform the operation on material $1$ twice. After these operations, we will have $3$ units of material $1$ and $8$ units of material $2$, which is more than enough to craft the artifact.

## 题解
1. 考虑如若a中有两个变量小于b中对应变量, 那么当一个增加k到对应的值, 另一个就减少k, 意味着这个值也会先增加k然后再增加相应的值h, 那么, 第一个值又减少k+h, 总体增量为0, 所以, 当有多于一个a中变量少于b中变量时, 不存在解
2. 当a中有一个值小于b中变量, 如果a增加的量小于$min(a_i-b_i)$, 那么可以增加这个值需要的大小, 得到解, 否则无解

## 参考代码
```cpp

#include<bits/stdc++.h>
#include <climits>
using namespace std;
#define i128 __int128
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define fi(x) for(int i = 1; i <= x; ++i)
#define fi0(x) for(int i = 0; i < x; ++i)
#define fj(n) for(int j = 1; j <= n; ++j)
#define fj0(n) for(int j = 0; j < n; ++j)
#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define PLEASE_AC return 0
#define startime auto start = chrono::high_resolution_clock::now();
#define endtime auto end = chrono::high_resolution_clock::now();
#define runningtime cout << "running time: " << chrono::duration_cast<chrono::milliseconds>(end - start).count()<<" ms\n";
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

int t, n;
const int N = 2e5 + 20;
int a[N], b[N];
void solve(){
	cin >> n;
	fi(n) cin >> a[i];
	fi(n) cin >> b[i];
	int mn = INT_MAX, cnt = 0, sm = 0;
	fi(n){
		if(a[i] < b[i]) 
			cnt++, sm = b[i] - a[i];
		else
			mn = min(mn, a[i] - b[i]);
	}

	if(cnt >= 2)
		cout << "NO\n";
	else {
		if((cnt == 0 || cnt == 1 && mn >= sm))
			cout << "YES\n";
		else 
			cout << "NO\n";
				
	}
}

signed main() {
//	freopen("an", "r", stdin);
	caillo;

	cin >> t;
	while(t--) solve();

	PLEASE_AC;
}

```

# 15. B. Shohag Loves Strings

## 题目
For a string $p$, let $f(p)$ be the number of distinct non-empty substrings$^{\text{∗}}$ of $p$.

Shohag has a string $s$. Help him find a non-empty string $p$ such that $p$ is a substring of $s$ and $f(p)$ is even or state that no such string exists.

$^{\text{∗}}$A string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.
## 输入
**Input**

The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.

The first and only line of each test case contains a string $s$ ($1 \le |s| \le 10^5$) consisting of lowercase English letters.

It is guaranteed that the sum of the length of $s$ over all test cases doesn't exceed $3 \cdot 10^5$.
## 输出
**Output**

For each test case, print a non-empty string that satisfies the conditions mentioned in the statement, or $-1$ if no such string exists. If there are multiple solutions, output any.
## 样例
### 输入
```
5
dcabaac
a
youknowwho
codeforces
bangladesh

```

### 输出
```
abaa
-1
youknowwho
eforce
bang

```

## 题解
可以从最短情况开始考虑:
1. 当有一个字符的时候, 不存在
2. 当有2个字符的时候:
	1. 两个是不同字符, 有三种子串, 不满足要求
	2. 两个是相同字符, 有两种子串, 满足要求
3. 当有三个字符的时候:
	1. 如果存在两个相邻相同的字符, 那么回到上面的情况
	2. 如果不存在两个相邻的相同字符
		1. 如果是三个不同字符, 那么, 有6个子串, 满足要求
		2. 如果是形如aba式的字符, 则不满足要求
4. 当有多个字符的时候, 可以考虑存在两个相邻相同字符或者三个不相同的相邻字符情况, 除此之外, 都不满足要求

## 参考代码
```cpp

#include<bits/stdc++.h>
#include <climits>
using namespace std;
#define i128 __int128
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define fi(x) for(int i = 1; i <= x; ++i)
#define fi0(x) for(int i = 0; i < x; ++i)
#define fj(n) for(int j = 1; j <= n; ++j)
#define fj0(n) for(int j = 0; j < n; ++j)
#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define PLEASE_AC return 0
#define startime auto start = chrono::high_resolution_clock::now();
#define endtime auto end = chrono::high_resolution_clock::now();
#define runningtime cout << "running time: " << chrono::duration_cast<chrono::milliseconds>(end - start).count()<<" ms\n";
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

int t, n;
const int N = 2e5 + 20;
int a[N], b[N];
void solve() {
	string s; cin >> s;
	if(s.size() == 1 || (s.size() == 2 && s[0] != s[1])) 
		cout << -1 << endl;
	else{
		if(s.size() == 2 && s[0] == s[1])
			cout << s << endl;
		else{

			for(int i = 0;i < s.size(); ++i){
				if(i > 0 && s[i] == s[i-1]){
					cout << s[i] << s[i] << endl;
					return;
				}
			}

			for(int i= 0;i < s.size(); ++i){
				if(i > 1){
					if(s[i] != s[i-1] && s[i] != s[i-2] && s[i-1] != s[i-2]){
						cout << s[i-2] << s[i-1] << s[i] << endl;
						return;
					}
				}
			}
			cout << -1 << endl;
		}
	}
		
}

signed main() {
//	freopen("an", "r", stdin);
	caillo;

	cin >> t;
	while(t--) solve();

	PLEASE_AC;
}

```

# 16. B. Pushing Balls

## 题目
Ecrade has an $n \times m$ grid, originally empty, and he has pushed several (possibly, zero) balls in it.

Each time, he can push one ball into the grid either from the leftmost edge of a particular row or the topmost edge of a particular column of the grid.

When a ball moves towards a position:

-   If there is no ball originally at that position, the incoming ball will stop and occupy the position.
-   If there is already a ball at that position, the incoming ball will stop and occupy the position, while the original ball will continue moving to the next position in the same direction.

Note that if a row or column is full (i.e., all positions in that row or column have balls), he cannot push a ball into that row or column.

Given the final state of whether there is a ball at each position of the grid, you need to determine whether it is possible for Ecrade to push the balls to reach the final state.

## 输入
**Input**

The first line contains an integer $t$ ($1 \le t \le 10\,000$) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $n$ and $m$ ($1 \le n, m \le 50$).

This is followed by $n$ lines, each containing exactly $m$ characters and consisting only of $0$ and $1$, describing the final state of the grid. There is a ball at one position of the grid if and only if the corresponding position of the given input is $1$.

It is guaranteed that the sum of $n\cdot m$ over all test cases does not exceed $10\,000$.
## 输出
**Output**

For each test case, output "Yes" (without quotes) if it is possible for Ecrade to push the balls to reach the final state, and "No" (without quotes) otherwise.

You can output "Yes" and "No" in any case (for example, strings "YES", "yEs" and "yes" will be recognized as a positive response).

## 样例
### 输入
```
5
3 3
001
001
110
3 3
010
111
010
3 3
111
111
111
3 3
000
000
000
3 3
000
000
001

```
### 输出
```
YES
YES
YES
YES
NO

```

## 题解
考虑i, j位置上有球时不合法的情况:
1. 如果i, j位置有球, 除了边界情况, 都应该左边/上面有球相邻
2. 如果即有上又有左边相邻球, 那么只要有一边满足要求就可以了
3. 如果只有一边相邻, 那么就检验
4. 如果没有相邻, 那么就完全不合法
用前缀和检验这个球之前是否连续

## 参考代码
```cpp
 
#include<bits/stdc++.h>
using namespace std;
#define i128 __int128
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define fi(x) for(int i = 1; i <= x; ++i)
#define fi0(x) for(int i = 0; i < x; ++i)
#define fj(n) for(int j = 1; j <= n; ++j)
#define fj0(n) for(int j = 0; j < n; ++j)
#define caillo ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define PLEASE_AC return 0
#define startime auto start = chrono::high_resolution_clock::now();
#define endtime auto end = chrono::high_resolution_clock::now();
#define runningtime cout << "running time: " << chrono::duration_cast<chrono::milliseconds>(end - start).count()<<" ms\n";
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

const int N = 55;
int t, n, m;
int mp[N][N], headc[N][N], headr[N][N];

void solve(){
	cin >> n >> m;
	fi(n)fj(m) {
		char ch; cin >> ch;
		mp[i][j] = ch - '0';
	}

	fi(n)fj(m) headc[i][j] = headc[i-1][j] + mp[i][j];
	fi(n)fj(m) headr[i][j] = headr[i][j-1] + mp[i][j];
	// fi(n){fj(m)cout << headc[i][j]<< ' ';cout << endl;}
	// fi(n){fj(m)cout << headr[i][j]<< ' ';cout << endl;}
	// cout << endl;
	// return;

	int is = 0;
	fi(n) mp[i][0] = 1;
	fi(m) mp[0][i] = 1;
	fi(n)fj(m){
		if(is == 1){
			cout << "NO\n";
			return;
		}
		if(mp[i][j]){
			if(!mp[i-1][j] && !mp[i][j-1])
				is = 1;
			else if(mp[i-1][j] && mp[i][j-1])
				is = ((headc[i][j] == i || headr[i][j] == j) ? 0 : 1);
			else if(!mp[i-1][j])
				is = ((headr[i][j] == j) ? 0 : 1);
			else if(!mp[i][j-1])
				is = ((headc[i][j] == i) ? 0 : 1);
		}
	}
	cout << (is ? "NO\n" : "YES\n");
}


signed main() {
//	freopen("an", "r", stdin);
	caillo;

	cin >> t;
	while(t--) solve();

	PLEASE_AC;
}

```

# 17. 
