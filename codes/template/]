
//注意左右移方向
//注意分割后边界mid+1
//注意参数意义与使用l和cl
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MAXN = 1e5 + 5;
ll tree[MAXN << 2], mark[MAXN << 2], n, m, A[MAXN];  //开4倍空间不会超限

void push_down(int p, int len)  //进一步访问子节点，把标记传递下去
{
    if (len <= 1) return;  //如果是叶子节点，就没有标记的必要，也不用传递，直接结束
	if(mark[p] == 1){
		tree[p<<1] = len/2;
		mark[p<<1] = 1;

		tree[p<<1|1] = len - len/2;
		mark[p<<1|1] = 1;
		mark[p] = 0;
	}else if(mark[p] == -1){
		tree[p<<1] = 0;
		mark[p<<1] = -1;

		tree[p<<1|1] = 0;
		mark[p<<1|1] = -1;
		mark[p] = 0;
	}
}

void build(int p = 1, int cl = 1, int cr = n)  //建树，递归，root为1
{
	memset(tree, 0, sizeof(tree));
	memset(mark, 0, sizeof(mark));
}


ll query(int l, int r, int p = 1, int cl = 1, int cr = n)  //查询，相同的操作
{
    if (cl >= l && cr <= r) return tree[p];  //如果目标范围包含当前范围，那么返回就有这个节点的数
    push_down(p, cr - cl + 1);  //否则就往下传递标记，向下搜索
    ll mid = (cl + cr) >> 1, ans = 0;  //把当前节点范围一分为二
    if (mid >= l) ans += query(l, r, p << 1, cl, mid);  //左子树被包含的情况，访问左子树
    if (mid < r) ans += query(l, r, p << 1 | 1, mid + 1, cr);  //右子树被包含的情况，访问右子树,判断mid 《 r是因为右节点是从mid+1开始的
    return ans;  //最后返回答案
}
void addmark0(int p){mark[p] = -1; tree[p] = 0;}
void addmark1(int p, int len){mark[p] = 1; tree[p] = len;}
void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n)  //修改区间，每个区间添加d
{
    if (cl >= l && cr <= r) {if(d == 1) addmark1(p, cr - cl+1);else if(d == 0) addmark0(p);}  //当前节点被完全包含，就直接标记，加上数值
    push_down(p, cr - cl + 1);  //当前节点没有被完全包含，那么就把标记传递下去，把数也传递到下一级
    int mid = (cl + cr) >> 1;  //一分为二
    if (mid >= l) update(l, r, d, p << 1, cl, mid);  //左子树有交集
    if (mid < r) update(l, r, d, p << 1 | 1, mid + 1, cr);  //右子树有交集
    tree[p] = tree[p << 1] + tree[p << 1 | 1];  //更新当前节点的数值为两子节点的和
}

bool check(int st, int mid, int tar){
	return mid - st + 1 - query(st, mid) >= tar;
}
void solve(){
	cin >> n >> m;
	build();
	// return;
	for(int i = 0;i <= m; ++i){
		int op, x, y;
		cin >> op >> x >> y;

		if(op == 1){
			// return;
			int total = query(x, n);
			// return;
			int fre = n - x + 1 - total;
			if(!fre) cout << "Can not put any one.\n";
			else {
				int ansl, ansr ;
				int l = x, r = n, mid;
				while(l <= r){
					mid = (l + r) >> 1;
					if(check(x, mid, 1)) r = mid - 1;
					else l = mid + 1;
				}
				return;
				ansl = l;
				l = x, r = n;
				while(l <= r){
					mid = (l + r) >> 1;
					if(check(x, mid, y)) r = mid - 1;
					else l = mid + 1;
				}
				ansr = l;
				cout << ansl << ' ' << ansr << endl;
				update(ansl, ansr, 1);
			}

		}else if(op == 2){
			update(x, y, 0);
			cout << endl;
		}
	}
}
int main()
{
    ios::sync_with_stdio(false);
	int t; cin >> t;
	while(t--) solve();
    return 0;
}
