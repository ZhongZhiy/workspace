### 这题看似很难，其实只需要一个**神**转化。

首先，我们来看这样一个问题：给你一个这样的序列：1,2,3,……,n，再给你一个1—n的排列，求他们的最长公共子序列。  
这个问题很简单，因为第一个序列是一个严格递增的，所以只要在第二个序列中找到一个上升子序列，那么一定会在第一个序列中出现，这个很好证明。如果要求最长公共子序列，那求最长上升子序列就行了。那回到原来的这个问题，这个问题第一个序列并不是严格递增的。但我们可以给他标号。  
如下：

```
原序列：3 2 1 4 5
  标号：1 2 3 4 5
```

那我们就把第一个序列变成了刚才的那个问题。注意了，第二个序列如果不做任何改变，那么你就会出问题。而第二个序列的改变方式也是标号。标号方式是和第一个序列一一对应。

```
p1
原序列：3 2 1 4 5
  标号：1 2 3 4 5
p2
原序列：1 2 3 4 5
  标号：3 2 1 4 4
```

上面p1中1标号为3，则p2中1的标号也是3。

这样，再对第二个序列的标号求最长上升子序列，就能得出答案了。

```cpp

#include<bits/stdc++.h>
using namespace std;
#define de(x) cout << #x << "=" << (x) << endl;
#define endl '\n'
#define de2(x,y) cout << #x << ' ' << #y << "=" << (x) << " ~ " << (y) << endl;
#define f(x) for(int i = 0;i < x; ++i)
#define f2(i,j) for(int k = i;k < j; ++ k)
typedef long long ll;
typedef unsigned long long ull;

const int N = 1e6 + 10;
int f[N], s[N], idx, dp[N];
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	f(n) {
		int t;
		cin >> t;
		f[t] = i + 1;
	}
	f(n) {
		int t;
		cin >> t;
		s[i]  = f[t];
	}

	f(n) {
		if(s[i] > dp[idx]) dp[++idx] = s[i] ;
		else{
			auto it = lower_bound(dp + 1, dp + 1 + idx, s[i]) - dp;
			dp[it] = s[i];
		}
	}

	cout << idx;

	return 0;

}
	
```