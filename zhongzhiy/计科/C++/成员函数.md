成员函数的声明必须在类的内部，但它的定义可以在类的内部或者外部，定义在内部的函数是隐式地inline函数
对于接口组成部分的非成员函数，它们定义和声明都在类的外部
```cpp
struct Sales_Data
{
std::string isbn() const {return bookNo;}
std::string isbn() const {return this ->bookNo;}//等价于

double avg_price() const;//外部定义

...
}
```
##### This
成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，我们调用一个成员函数时，用该函数的对象地址初始化this，例如
`total.isbn()`实际是把total的地址传递给了this，然后调用this所指对象（total)的成员`total.bookNo`

##### const成员函数，常量成员函数
这里const 关键字的作用是修改隐式this指针的类型，即`Sale_data *const`，提高函数灵活性
默认情况下this的类型是指向类类型非常量版本的常量指针，意味着（默认情况）不能把this绑定到一个常量对象上

##### 编译器分两步处理类
1. 首先编译成员的声明
2. 再编译成员函数体
因此，成员函数可以随意使用类的其他成员而不用在意这些成员的出现顺序

##### 在类外部定义成员函数
定义必须与声明匹配，类外部定义的成员的名字必须包含它所属的类名
```cpp
doubt Sales_data::avg_price()  const {//外部定义需要包含类名体现在Sales_data：：作用域
if(unit_sold)
return revenue/units_sold;
else
return 0;
}
```

##### 返回调用该函数的对象
```cpp
Sales_data& Sales_data::conbine(const Sale_data &rhs)
{
units_sold += rhs.units_sold;//this对象是total，把total.units_sold += rhs.units_sold
revenue += rhs.revenue; //这里把total.revenue += rhs.revenue
return *this;//返回函数类型是引用
}

调用函数
total.combine(trans);//total这里是this，trans是&rhs是一个引用，相加结果储存到total里
```

#### 定义非成员函数

