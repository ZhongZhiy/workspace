C++ 中的 **宏（macro）** 和 **宏函数（macro function）** 是通过 `#define` 预处理指令定义的，在编译前会进行**文本替换**。这使它们比普通的 `const` 或 `inline` 函数更快，但也更容易出错。以下是一些常见用法：

---

## 🌟 **1. 定义常量**

```cpp
#define PI 3.141592653589793
#define MAX_SIZE 1000
```

- 作用：在代码中用 `PI` 代替 `3.141592653589793`，用 `MAX_SIZE` 代替 `1000`。
- ⚠️ **建议用 `const` 替代**：
    
    ```cpp
    const double PI = 3.141592653589793;
    ```
    

---

## 🌟 **2. 宏函数（带参数的宏）**

```cpp
#define SQUARE(x) ((x) * (x))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
```

- **`SQUARE(5)`** 会展开成 **`((5) * (5))`**，结果是 `25`。
- **`MIN(3, 7)`** 展开成 **`((3) < (7) ? (3) : (7))`**，结果是 `3`。
- **⚠️ 括号陷阱**：
    
    ```cpp
    #define ADD(a, b) a + b
    int x = 2 * ADD(3, 4);  // 变成 2 * 3 + 4 = 6 + 4 = 10（错误！）
    ```
    
    **正确写法**：
    
    ```cpp
    #define ADD(a, b) ((a) + (b))
    ```
    

🔹 **更好的替代方案**：用 `inline` 函数

```cpp
inline int square(int x) { return x * x; }
inline int min(int a, int b) { return (a < b) ? a : b; }
```

✅ **不会有括号陷阱，也能被编译器优化**。

---

## 🌟 **3. 条件编译**

```cpp
#define DEBUG
#ifdef DEBUG
    #define LOG(x) cout << "Debug: " << x << endl;
#else
    #define LOG(x)
#endif
```

- **如果 `DEBUG` 被定义，`LOG(x)` 会展开为 `cout << "Debug: " << x << endl;`**。
- **如果 `DEBUG` 没定义，`LOG(x)` 直接变为空，不会影响编译**。

---

## 🌟 **4. 防止头文件重复包含**

**方式 1：使用 `#ifndef`**

```cpp
#ifndef MY_HEADER_H
#define MY_HEADER_H

// 头文件内容

#endif // MY_HEADER_H
```

- **原理**：如果 `MY_HEADER_H` **没有被定义**，才会包含头文件内容，防止重复定义。

**方式 2：使用 `#pragma once`**

```cpp
#pragma once
```

- **作用**：保证头文件只被编译一次，**比 `#ifndef` 方式更高效**（但不是所有编译器都支持）。

---

## 🌟 **5. 代码展开和调试**

```cpp
#define PRINT_VAR(x) cout << #x << " = " << x << endl;
```

```cpp
int a = 42;
PRINT_VAR(a);  // 展开为 cout << "a" << " = " << a << endl;
```

- `#x` **会把参数变成字符串**，所以 `PRINT_VAR(a)` **等效于 `cout << "a = 42" << endl;`**。

---

## 🌟 **6. 可变参数宏（变长参数 `...`）**

```cpp
#define LOG(fmt, ...) printf(fmt, ##__VA_ARGS__)
```

用法：

```cpp
LOG("Hello, world!\n");  
LOG("Sum of %d and %d is %d\n", 3, 4, 3 + 4);
```

- `##__VA_ARGS__` **在没有参数时会自动去掉前面的 `,`，否则正常替换**。

---

## 🌟 **7. 计算数组大小**

```cpp
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
```

用法：

```cpp
int arr[] = {1, 2, 3, 4, 5};
cout << "数组大小: " << ARRAY_SIZE(arr) << endl;  // 输出 5
```

---

## 🌟 **8. 定义跨平台代码**

```cpp
#ifdef _WIN32
    #define CLEAR_SCREEN "cls"
#else
    #define CLEAR_SCREEN "clear"
#endif
```

这样可以用：

```cpp
system(CLEAR_SCREEN);
```

无论是 Windows 还是 Linux，都能正确清屏。

---

## 🚀 **总结**

|用途|预处理宏示例|替代方案|
|---|---|---|
|**定义常量**|`#define PI 3.14159`|`const double PI = 3.14159;`|
|**宏函数**|`#define SQUARE(x) ((x)*(x))`|`inline int square(int x) { return x * x; }`|
|**条件编译**|`#ifdef DEBUG ... #endif`|`const bool debug = true;`|
|**防止重复包含**|`#ifndef MY_HEADER_H ... #endif`|`#pragma once`|
|**调试打印**|`#define PRINT_VAR(x) cout << #x << " = " << x << endl;`|`cout << "x = " << x << endl;`|
|**数组大小**|`#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))`|`std::size(arr)`|

---

## 🛑 **⚠️ 为什么要少用宏？**

- **容易出错**（括号陷阱、意外展开）。
- **调试困难**（宏不会生成函数符号）。
- **可读性差**（特别是嵌套宏）。
- **C++ 现代化建议**：尽量用 `const`、`inline`、`constexpr`、`template` 代替。

**在 C++ 里，宏应该谨慎使用，尽量用现代 C++ 特性替代！** 🚀