# cs61a

## 用户函数调用时环境的创建过程是怎样的？

<!-- notecardId: 1760541170058 -->

1. 创建一个新的 frame
2. 将实参绑定到形参
3. 执行函数体

---

## 什么是 frame？

<!-- notecardId: 1760541170066 -->

在 Python 的环境模型中，**frame** 是保存变量绑定（名称→值）的数据结构，用于表示一个作用域。

---

## 在函数调用中，frame 与环境 (environment) 的关系是什么？

<!-- notecardId: 1760541170072 -->

环境由一系列 frame 组成，每个 frame 记录一组名称绑定，并且有一个指向其 **parent frame** 的引用，形成链式结构。

---

## 嵌套定义中，每个用户函数都有一个 {{c1::parent frame（通常是全局 frame）}}。

<!-- notecardId: 1760541170078 -->

---

## 函数的 parent frame 是什么？

<!-- notecardId: 1760541170095 -->

函数的 parent frame 是定义该函数时所在的 frame。

---

## 每个 local frame 的 parent frame 是什么？

<!-- notecardId: 1760541170100 -->

每个 local frame 都有一个 parent frame（通常是 global frame）。

---

## 当调用函数时，新的 frame 的 parent 是什么？

<!-- notecardId: 1760541170107 -->

被调用函数的 frame 的 parent 是该函数的 **parent frame**。

---

## lambda 表达式的基本语法是什么？

<!-- notecardId: 1760541170112 -->

```python
lambda 参数: 表达式
```

---

## lambda 表达式代表什么？

<!-- notecardId: 1760541170117 -->

`lambda x: f(g(x))` 表示一个 **接受参数 x 并返回 f(g(x)) 的函数**。

---

## 什么是 Function Currying（函数柯里化）？

<!-- notecardId: 1760541170122 -->

将一个接受多个参数的函数转化为 **一系列每次只接受一个参数的函数** 的过程。
例如：
$f(x, y) \Rightarrow g(x)(y)$，其中 $g$ 是高阶函数。

---

## return 语句的作用是什么？

<!-- notecardId: 1760541170127 -->

`return` 语句结束函数调用的执行，并返回其计算结果。

---

## 用户定义函数执行时环境如何切换？

<!-- notecardId: 1760541170132 -->

1. 调用函数：切换到新环境，执行函数体。
2. `return`：切换回上一个环境，并将结果返回。

---

## 什么是闭包（closure）？

<!-- notecardId: 1760541170136 -->

闭包是一个函数（通常是内部函数）+ 它定义时所在作用域中的变量绑定（enclosing environment）。

---

## 闭包能“记住”什么？

<!-- notecardId: 1760541170141 -->

闭包能记住**函数定义时**的外部变量，即使外部函数已经执行完毕。

---

## 闭包形成的三个条件中，第一个条件是 {{c1::函数嵌套（函数中定义函数）}}。

<!-- notecardId: 1760541170147 -->

---

## 闭包形成的三个条件中，第二个条件是 {{c2::内部函数引用外部函数的变量}}。

<!-- notecardId: 1760541170153 -->

---

## 闭包形成的三个条件中，第三个条件是 {{c3::外部函数返回内部函数}}。

<!-- notecardId: 1760541170157 -->

---

## 闭包的价值：它可以让函数“记住”{{c1::状态}}，适合数据封装、延迟计算、函数工厂等场景。

<!-- notecardId: 1760541170162 -->

---

## 闭包实现数据封装的示例是？

<!-- notecardId: 1760541170166 -->

```python
def make_counter():
    count = 0
    def add_one():
        nonlocal count
        count += 1
        return count
    return add_one
```

此时 `count` 保存在闭包中，即使外层函数结束仍可访问。

---

## 闭包实现延迟计算的示例？

<!-- notecardId: 1760541170172 -->

```python
def multiplier(n):
    return lambda x: x * n

times3 = multiplier(3)
times3(5)  # 输出 15
```

---

## 闭包作为函数工厂的示例？

<!-- notecardId: 1760541170175 -->

```python
def power(p):
    return lambda x: x ** p

square = power(2)
cube = power(3)
```

---

## 为什么闭包比普通函数更强大？

<!-- notecardId: 1760541170179 -->

因为闭包能携带状态，在没有类的情况下实现封装、记忆和高阶行为。

---

