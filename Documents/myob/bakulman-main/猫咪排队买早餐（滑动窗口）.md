### 问题 F: 猫咪排队买早餐

时间限制: 3.000 Sec  内存限制: 512 MB  

#### 题目描述

最近喵喵来到了猫咪国旅行，这里充满各种品种的可爱猫咪，如 bb 猫、加菲猫、电喵、小肥猫⋯⋯等，只要你能想到的，这边都能够看到。  

在这边待了几天的喵喵，发现猫咪国有一家非常热门的早餐店 ──NPSC。每天早上，都会有数以万计的猫咪在店门口排队，想要吃 NPSC 的早餐。  

看到这么多猫咪在吃 NPSC 的早餐，难道喵喵不会想吃吃看吗？  

喵喵还真的不想吃！比起吃 NPSC 的早餐，喵喵更喜欢观察那些排在队伍中的可爱猫咪们！  

现在，喵喵发现有 N 只猫咪正在排队，从左到右的品种分别为 a1,a2,...,aN 。为了方便，喵喵告诉你的品种都已经换成正整数来表示了，也就是说 a1,a2,...,aN 皆为不超过 106 的正整数。  

此外，喵喵还发现，如果品种相同的猫咪排在相邻的位置，那他们便会开始玩耍起来，进而感受不到因漫长排队所产生的无聊感，这也是喵喵最喜欢看到的现象。  

充满好奇心的喵喵，看着这 N 只正在排队的猫咪，不禁心想，如果他能把至多 1 只猫咪的品种改变成任何品种，喵喵可以看到「最长连续相同品种的猫咪数量」最大可以是多少呢？  

也许你会问，喵喵要如何改变猫咪的品种呢？这个问题简单！喵喵可以用染毛剂来帮猫咪换颜色，猫咪们便可以假装改变品种啰！由于喵喵手边只有 1 个染毛剂，因此至多只能帮 1 只猫咪改变品种。  

其次，你可能会好奇，「连续相同品种的猫咪数量」的意思是什么？举个例子，若存在一个区间 [l,r] ，满足 al = al+1 = ... = ar ，那么 r − l + 1 便是「连续相同品种的猫咪数量」。  

  
  

  
  

#### 输入

输入第一行有一个非负整数 N ，代表队伍中猫咪的数量。  
输入第二行有 N 个正整数 a1,a2,...,aN，分别代表从左至右每只猫咪的品种。  
  
  

#### 输出

输出一个整数于一行，代表在喵喵可以改变至多 1 只猫咪品种的情况下，喵喵可以看到「最长连续相同品种的猫咪数量」最大可以是多少。  
  
  

#### 样例输入 Copy

【输入样例1】
3
1 2 1

【输入样例2】
5
1 2 1 2 1

#### 样例输出 Copy

【输出样例1】
3

【输出样例2】
3

#### 提示

【数据规模】  
• $1 ≤ N ≤ 10^6$  
• $1 ≤ ai ≤ 10^6$

## 题意
在长度为n的数组中，找到最长一个子数组满足最多只有一个数字不同。
本质就是滑动窗口，有很多类似的题型

解析：[[滑动窗口]]
关键维护一个统计频率的变量
参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define f(n) for(int i = 0;i < n; ++i)
#define ff(i, a, b) for(int i = a; i < b; ++i)
typedef long long ll;
typedef unsigned long long ull;
#define int long long 
 
 
const int N = 1e6 + 100;
int v[N];
unordered_map<int, int> mp;
 
signed main() {
//  freopen("an", "r", stdin);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
 
 
    int n;
    cin >> n;
 
    for(int i = 1 ;i <= n; ++i) cin >> v[i];
 
 
    int l = 1, r = 0, foo = 1, cnt = 0, max_c = 0;
    while(r < n) {
        mp[v[++r]]++;
        max_c = max(mp[v[r]], max_c);
        while((r-l+1) - max_c > 1) {
            mp[v[l]]--;
            l++;
        }
 
        cnt = max(cnt, r - l + 1);
    }
 
    cout << cnt;
 
    return 0;
}
```
 

