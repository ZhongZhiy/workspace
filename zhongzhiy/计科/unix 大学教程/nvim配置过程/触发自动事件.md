---
tags:
  - vim
---
在 Neovim 中，`event` 是用于触发自动命令（autocommand）的事件。它们通常用于响应特定操作或状态变化时执行某些动作，比如打开文件、保存文件、切换窗口等。

你可以通过 `vim.api.nvim_create_autocmd()` 来创建一个基于事件的自动命令，如下所示：

```lua
vim.api.nvim_create_autocmd("BufEnter", {
  pattern = "*.lua",
  callback = function()
    print("你打开了一个 Lua 文件！")
  end,
})
```

---

## ✅ 常见的 `event` 选项及其解释

以下是 Neovim 中常用的事件类型及其含义（整理自官方文档和 Lua 指南）：

---

### 📄 文件相关事件（File Events）

| 事件名称 | 触发时机 | 示例 |
|----------|-----------|------|
| `BufNewFile` | 创建新文件并进入缓冲区时（如 `:e newfile.txt`） | 新建文件时设置默认内容 |
| `BufRead` | 打开已有文件并加载到缓冲区后 | 设置特定文件类型的配置 |
| `BufReadPost` | 缓冲区读取完成后 | 加载文件后运行某个插件 |
| `BufReadPre` | 缓冲区读取前 | 在读取大文件前禁用某些功能 |
| `BufWrite` | 文件写入磁盘时（`:w`） | 写入时格式化代码 |
| `BufWritePre` | 文件写入前 | 写入前检查语法错误 |
| `BufWritePost` | 文件写入完成后 | 提示“已保存”信息 |
| `BufAdd` | 缓冲区被添加到列表中 | 当某个缓冲区被加入时触发 |
| `BufCreate` | 缓冲区被创建时 | 创建缓冲区时初始化变量 |
| `BufDelete` | 缓冲区被删除时 | 清理资源或变量 |
| `BufUnload` | 缓冲区卸载时（关闭文件时） | 释放占用的内存或临时资源 |

---

### 💾 窗口与标签页事件（Window/Tab Events）

| 事件名称 | 触发时机 | 示例 |
|----------|-----------|------|
| `WinEnter` | 进入某个窗口时 | 切换窗口时更新状态栏 |
| `WinLeave` | 离开某个窗口时 | 离开时保存状态 |
| `TabEnter` | 进入某个标签页时 | 根据标签页恢复设置 |
| `TabLeave` | 离开某个标签页时 | 清理标签页相关变量 |

---

### 🖱️ 用户交互事件（User Interaction Events）

| 事件名称 | 触发时机 | 示例 |
|----------|-----------|------|
| `InsertEnter` | 进入插入模式时 | 启动输入法、关闭自动补全 |
| `InsertLeave` | 离开插入模式时 | 自动保存或格式化 |
| `CursorHold` | 光标停留一段时间后 | 显示提示信息或跳转定义 |
| `CursorMoved` | 光标移动时 | 高亮当前行或更新大纲 |
| `TextChanged` | 文本发生变化时（不包括插入模式） | 实时语法检查 |
| `TextChangedI` | 插入模式中文本变化时 | 实时补全 |
| `ModeChanged` | 模式切换时（如从 normal 到 insert） | 改变状态栏颜色 |
| `FocusGained` | Neovim 获得焦点时（GUI 或终端中） | 自动刷新或重新加载配置 |
| `FocusLost` | Neovim 失去焦点时 | 暂停某些高消耗操作 |

---

### 🧠 Vim 生命周期事件（Startup/Shutdown Events）

| 事件名称 | 触发时机 | 示例 |
|----------|-----------|------|
| `VimEnter` | Vim 启动完成时 | 初始化插件或 UI 设置 |
| `VimLeave` | Vim 退出前 | 保存会话或清理缓存 |
| `UIEnter` | UI 接口就绪后（GUI 或终端） | 启用图形界面支持的功能 |
| `TermOpen` | 终端缓冲区打开时 | 设置终端快捷键或配色 |
| `TermClose` | 终端缓冲区关闭时 | 清理终端相关的配置 |

---

### 🔄 缓冲区状态事件（Buffer State Events）

| 事件名称 | 触发时机 | 示例 |
|----------|-----------|------|
| `FileType` | 文件类型被检测到时 | 根据文件类型启用插件 |
| `Syntax` | 语法高亮被加载后 | 添加自定义语法高亮规则 |
| `ColorScheme` | 颜色主题切换后 | 修改部分颜色适配你的插件 |
| `OptionSet` | 某个选项被修改时 | 监控 `relativenumber` 变化 |
| `CmdlineEnter` | 进入命令行模式时 | 自定义命令历史 |
| `CmdlineLeave` | 离开命令行模式时 | 清除临时状态 |
| `CompleteDone` | 补全完成时 | 对补全后的文本做处理 |
| `TextYankPost` | 使用 `y` 命令复制文本后 | 高亮刚刚复制的内容 |

---

### 📁 系统与外部事件（System & External Events）

| 事件名称 | 触发时机 | 示例 |
|----------|-----------|------|
| `DirChanged` | 当前目录更改时（如 `:cd`） | 更新工作区状态 |
| `SessionLoadPost` | 从会话中恢复后 | 恢复插件状态 |
| `ShellCmdPost` | 执行 shell 命令后 | 自动刷新文件列表 |
| `RemoteReply` | 接收到远程请求回复时 | 处理 RPC 请求 |

---

### 🔀 其他常用事件（Other Common Events）

| 事件名称 | 触发时机 | 示例 |
|----------|-----------|------|
| `User` | 用户自定义事件 | 插件之间通信使用 |
| `FileType` | 文件类型被设置后 | 为 `.lua` 文件启用 LSP |
| `VeryLazy` | kickstart.nvim 中的懒加载触发事件 | 延迟加载插件以提升启动速度 |

---

## 🧩 如何查看所有可用事件？

在 Neovim 中，你可以直接运行以下命令查看所有支持的事件：

```vim
:help events
```

或者在 Lua 中列出所有事件：

```lua
for event in pairs(vim.api.nvim_get_all_events()) do
  print(event)
end
```

---

## 🎯 示例：使用 `event` 实现懒加载插件

```lua
vim.api.nvim_create_autocmd("FileType", {
  pattern = "lua",
  callback = function()
    require("my-lua-plugin").setup()
  end,
})
```

这段代码会在打开 `.lua` 文件时才加载插件，从而实现 **按需加载**，提高 Neovim 的启动性能。

---

## 📌 总结

| 类型 | 常用事件 | 用途 |
|------|-----------|------|
| 文件操作 | `BufRead`, `BufWrite`, `BufNewFile` | 文件打开、保存、新建时触发操作 |
| 插入模式 | `InsertEnter`, `InsertLeave` | 控制输入行为 |
| 编辑交互 | `CursorHold`, `TextChanged` | 实时检查或预览 |
| 生命周期 | `VimEnter`, `VimLeave` | 初始化或退出时的操作 |
| 模式切换 | `ModeChanged`, `InsertEnter` | 模式变化时的行为控制 |
| 懒加载 | `FileType`, `VeryLazy`, `User` | 插件延迟加载 |

---

如果你正在使用 `kickstart.nvim`，你会发现它大量使用了这些事件来优化插件加载顺序和性能。  
例如，很多插件都通过 `FileType` 或 `VeryLazy` 来实现延迟加载，避免影响启动速度。

---

如果你想了解如何根据具体需求选择合适的事件，欢迎继续提问 😊