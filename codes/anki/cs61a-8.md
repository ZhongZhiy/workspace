# cs61a

## 什么是递归函数（recursive function）？

<!-- notecardId: 1760619279220 -->

如果函数体内部调用了**自身（直接或间接）**，该函数就是递归函数。

---

## 执行递归函数体时意味着什么？

<!-- notecardId: 1760619279225 -->

意味着在执行过程中可能需要**再次调用该函数自身**。

---

## 递归的两个关键要素是什么？

<!-- notecardId: 1760619279230 -->

1. **基例（base case）**：终止递归
2. **递归调用（recursive call）**：将问题分解为更小的子问题

---

## 以下函数 sum_digits 的作用是什么？

计算一个正整数的各位数字之和。

---

## 在递归函数 sum_digits 中，split(n) 的作用是？

将整数 $n$ 分解为：

* 除去最后一位的部分：$n // 10$
* 最后一位：$n % 10$

---

## sum_digits 的递归逻辑是什么？

$$
sum_digits(n) =
\begin{cases}
n, & n < 10 \
sum_digits(all_but_last) + last, & n \ge 10
\end{cases}
$$

---

## “递归信仰之跃（recursive leap of faith）” 是什么？

<!-- notecardId: 1760619279249 -->

一种递归思维方式：
假设递归调用（例如 `fact(n-1)`) 已经正确实现，然后在此假设下验证当前步骤的正确性。

---

## 验证递归函数正确性的四个步骤？

<!-- notecardId: 1760619279254 -->

1. 验证基例是否正确
2. 把递归函数视为一个抽象的功能
3. 假设递归调用是正确的
4. 基于假设验证当前步骤正确性

---

## 互相递归（mutual recursion）是什么意思？

<!-- notecardId: 1760619279259 -->

两个或多个函数**彼此调用**的递归形式。

---

## Luhn 算法的用途是什么？

<!-- notecardId: 1760619279264 -->

用于验证信用卡号码是否合法。

---

## Luhn 算法的基本原理？

<!-- notecardId: 1760619279268 -->

将数字分为奇偶位：

* 偶数位数字翻倍（大于9则拆分求和）
* 奇数位保持不变
* 最终总和应为 10 的倍数

---

## 将递归转化为迭代的意义是什么？

<!-- notecardId: 1760619279273 -->

通过消除函数自调用，使用循环结构提高效率并减少栈开销。

---

## 以下函数 cascade(n) 展示了递归的哪种特征？

<!-- notecardId: 1760619279278 -->

```python
def cascade(n):
    if n < 10:
        print(n)
    else:
        print(n)
        cascade(n//10)
        print(n)
```

👉 说明递归调用可出现在递归前后，因此可**控制执行顺序与输出结构**。

---

## 在 cascade(123) 执行时，有几个不同的 frame？

<!-- notecardId: 1760619279282 -->

每次递归调用都会生成一个新的 frame，因此有 3 个不同的 frame。

---

## inverse_cascade 的输出模式是什么？

```
1
12
123
1234
123
12
1
```

显示递归的“生长与收缩”结构。

---

## 什么是树形递归（tree recursion）？

<!-- notecardId: 1760619279291 -->

函数在每次调用中会**递归调用自身多次**，形成树状调用结构。

---

## 斐波那契数列函数 fib(n) 是哪种递归？

<!-- notecardId: 1760619279296 -->

典型的**树形递归（tree recursion）**。

---

## count_partitions(n, m) 的问题建模思想是什么？

递归分解为两个子问题：

1. **包含 m 的情况**：`count_partitions(n - m, m)`
2. **不包含 m 的情况**：`count_partitions(n, m - 1)`

---

## count_partitions 的基例有哪些？

* 若 $n = 0$ → 返回 1
* 若 $n < 0$ → 返回 0
* 若 $m = 0$ → 返回 0

---

## 为什么 count_partitions(6,4) 的结果是 9？

因为有 9 种不同的正整数分法，使得和为 6 且最大数不超过 4。

---

## 树形递归的缺点是什么？

<!-- notecardId: 1760619279316 -->

重复计算导致 **指数级时间复杂度**。

---

## 优化树形递归的常见方法？

<!-- notecardId: 1760619279320 -->

使用 **记忆化（memoization）** 或 **迭代改写** 来减少重复调用。

