### 问题 E: 持家

时间限制: 2.000 Sec  内存限制: 512 MB  

#### 题目描述

身为魔法少女的小 hua 可能从未考虑过，是否也会有要肩负起家庭与责任的一天。  
  
小 hua 在拼夕夕上想购买原价为 P 元的商品，由于拼夕夕是良心商家，他提前发放了 n 张优惠券给小 hua。  
  
本次购物，小 hua 被允许按照任意顺序使用 k 张优惠券。  
  
优惠券分两种：  

- 打折券，打 x 折，其中 x∈1,2,3,…,9。
- 减免券，直接减 x 元。

商家不会倒贴钱给他，她的花费最少是 0 元。 优惠券均可叠加，例如使用两张 8 折券，则可以以 6.4 折的价格买下商品。  

#### 输入

第一行一个整数 T 表示测试数据组数。  
  
对于每组数据：  
  
一行三个整数 P,n,k 表示商品初始价格、优惠券张数、优惠券使用上限。  
  
接下来 n 行，每行两个整数ti,pi。  
ti=0 表示这张券可以打 pi 折(1≤pi≤9)。  
ti=1 表示这张券可以减 pi 元(1≤pi≤109)。  

#### 输出

对于每组数据，输出一行一个浮点数（保留两位小数）表示买下商品的最小花费。

#### 样例输入 Copy

3
79 4 2
0 9
1 14
0 5
0 8
71 4 3
1 22
1 3
0 6
0 7
70 5 3
1 18
0 2
0 1
0 9
1 7

#### 样例输出 Copy

25.50
7.82
0.00

#### 提示

对于所有数据：$1≤T≤100,1≤n≤10^4,1≤P≤10^9,1≤k≤n$。

## 题意
从打折券和减免券中选择k张，令商品价格最小

## 分析
最开始我以为是贪心，每次选择在当前价格减免最多的行为，但是在样例的第二组中，倒数第二次选择中，`减免+打折`会被优先选择，但是实际上`打折+减免`才是更优的决择，所以这样的选择策略是错误的。

而可以考虑到打折券应该比减免优先，才能最优，所以枚举k张优惠券，打折券的张数，选出最优的，但是我担心会超时，幸好每超时。

### 参考代码
```cpp

#include<bits/stdc++.h>
using namespace std;
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define f(n) for(int i = 0;i < n; ++i)
#define ff(i, a, b) for(int i = a; i < b; ++i)
typedef long long ll;
typedef unsigned long long ull;


int main() {
//	freopen("an", "r", stdin);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while(t--) {
		int  n, k;
      		double p;
		cin >> p >> n >> k;

		vector<int> a, b;
		f(n) {
			int x, y;
			cin >> x >> y;

			if(x == 0) a.push_back(y);
			else b.push_back(y);
		}

		sort(a.begin(), a.end());
		sort(b.begin(), b.end(), greater<int>());

		double ans = p;
		for(int i = 0;i <= min(k, (int)a.size()); ++i) {
			double q = p;
			for(int j = 0;j < i; ++j) {
				q *= 1.0* a[j];
				q /= 10.0;
				
			}
			for(int l = 0;l < min(k - i, (int)b.size()); ++l) {
				q = max(0.0, q - b[l]);
			}
			ans = min(ans, q);

		}

		cout << fixed << setprecision(2) << ans << endl;
	}
	return 0;
}

```