1. 比较字符串s和t中字序, 用两个指针一步一步移动,相同一起移动,不同则移动一根,s=t顺序的结果为目标字符串指针到达末尾
2. **将n划分成k个数的划分法：**

　$dp[n][k]= dp[n-k][k]+ dp[n-1][k-1];$

   方法可以分为两类：  
   　第一类: n 份中**不包含 1 的分法**，为保证每份都 >= 2，可以先拿出 k 个 1 分  
   　到每一份，然后再把剩下的 n- k 分成 k 份即可，分法有: $dp[n-k][k]$ 
  　　 　　第二类: n 份中至少有一份为 1 的分法，可以先那出一个 1 作为单独的1份，剩  
   　　下的 n- 1 再分成 k- 1 份即可，分法有：$dp[n-1][k-1]$

3. 定义`dp[n]`为有n个方格情况下所有满足要求的涂法。

对于`dp[n]`，我们看作是向`n-1`个格子组成的序列中插入一个新格子，这`n-1`个格子可以本身就满足要求(相邻异色，首尾异色)，这时我们新加入的格子就只能选择一个颜色，所以选法就是`dp[n-1]`。这`n-1`个格子也可以不满足要求，因为我们的第n个格子马上要成为尾格子，只要第n个格子和首格子不同，整体还是满足要求的。这时选法是`dp[n-2]*2`个，见下图。

4. 有开始时间和结束时间,让一段时间中安排活动尽可能多, 那就让活动按照结束时间排序,越早结束说明留给其他活动时间越多
5. 输入一个高精度的正整数n（≤240位），去掉其中任意s个数字后，剩下的数字按原左右次序组成一个新的正整数。编程对给定的n和s，寻找一种方案，使得剩下的数字组成的新数最小。应该删去峰值,而不是从左往右删最大的
6. 方向数组,找边界情况转弯
```cpp
int n;  
cin >> n;  
int dira[4]{0,1,0,-1};  
int dirb[4]{1,0,-1,0};  
vector<vector<int>> a(n + 2, vector<int>(n + 2, 0));  
int cnt = 0,x = 1,y = 1;a[1][1] = 1;int q = 0;  
while (++cnt <= n*n)  
{  
    a[x][y] = cnt;  
    int nx = x + dira[q];  
    int ny = y + dirb[q];  
    if (nx < 1 || nx > n || ny < 1 || ny > n || a[nx][ny] != 0) {  
        q = (q + 1) % 4;  
        nx = x + dira[q];  
        ny = y + dirb[q];  
    }  
    x = nx;  
    y = ny;  
}

```


混合背包,多重背包优化
```cpp
for(int i=0;i<n;i++){  
    int v,w,p;  
    cin >> v >> w >> p;  
    if(p==0){  
        for(int j=v;j<=m;j++){  
            dp[j] = max(dp[j],dp[j-v]+w);  
        }  
    } else {  
        int k=1;  
        while(p>0)  
            {  
            int x = min(p,k);  
            p -= x;  
            int tv = v*x, tw = w*x;  
            for(int j=m;j>=tv;j--){  
                dp[j] = max(dp[j],dp[j-tv]+tw);  
            }  
            k <<=1;  
        }  
    }  
}
```


那么**什么时候适用二分答案呢**？注意到题面：使得选手们在比赛过程中的最短跳跃距离尽可能长。如果题目规定了有“最大值最小”或者“最小值最大”的东西，那么这个东西应该就满足二分答案的有界性（显然）和单调性（能看出来）。



d常见dp
这道题我们可以用dp:

`f[i][x]` 表示 i 分成 x 个非空的数的方案数。

显然 i<x 时 `f[i][x]=0` , i=x 时 `f[i][x]=1`;

其余的状态，我们分情况讨论：

①有1的 ②没有1的

第一种情况，方案数为 `f[i-1][x-1]`

第二种情况，方案数为 `f[i-x][x]` (此时 i 必须大于 x)

所以，状态转移方程为： `f[i][x]=f[i-1][x-1]+f[i-x][x]`



边界条件检查在 `if` 中的顺序会导致运行错误。例如，`row > n` 或 `row < 1` 这样的边界检查应该放在前面，否则会在访问 `v[row][col]` 时发生**数组越界错误**。





|     |     |
| --- | --- |
我们不妨设第n个人给第一个人的糖果数为x1,第一个人给第二个人的为x2,第二个给第三个的为x3，......,第n-1个人给第n个人的为xn,则：

答案为$∣x1∣+∣x2∣+∣x3∣+......+∣xn∣∣x1​∣+∣x2​∣+∣x3​∣+......+∣xn​∣$

且满足条件：$x_{i+1}=a_{i}-average+x_{i}$
$x_{2}=a_{1}-ave+x_{1}$
$x_{3}=a_{2}-ave+x_{2}=(a_{1}-ave)+(a_{2}-ave)+x_{1}$
$x_{4}=a_{3}-ave+x_{3}=(a_{1}-ave)+(a_{2}-ave)+(a_{3}-ave)+x_{1}$
$x_{n}=(a_{1}-ave)+......+(a_{n}-1-ave)+x_{1}$
s设 : $c_{n}=\sum _{i=1}^{n}ave-a_{i}$
$|x_{1}|+|x_{1}+c_{1}|+......+|x_{1}+c_{n}-1|$


因数有奇数个的数为完全平方数

### **对数相关函数总结表**

| 函数         | 作用          | 公式        | 参数要求 |
| ---------- | ----------- | --------- | ---- |
| `log(x)`   | 自然对数        | ln⁡(x)    | x>0  |
| `log10(x)` | 以 10 为底的对数  | log⁡10(x) | x>0  |
| `log2(x)`  | 以 2 为底的对数   | log⁡2(x)  | x>0  |
| `log1p(x)` | 计算 ln⁡(1+x) | ln⁡(1+x)  | x>−1 |
| `exp(x)`   | 计算 e^x      | e^x       | 无限制  |
| `expm1(x)` | 计算e^x - 1   | e^x - 1   | 无限制  |
