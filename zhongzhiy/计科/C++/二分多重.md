

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/104696076)

一共七种查找要求：

1、查找数组中等于 key 的数字

2、查找数组中第一个等于 key 的数字

3、查找数组中最后一个等于 key 的数字

4、查找数组中第一个大于等于 key 的数字

5、查找数组中最后一个小于等于 key 的数字

6、查找数组中第一个大于 key 的数字

7、查找数组中最后一个小于 key 的数字

一、查找数组中等于 key 的数字
-----------------

 也是最基本的二分查找，:::这种情况下有等于 key 的情况下返回该数字的下标，但是如果一个数组中有多个等于 key 的数字，那么不能确定返回的是哪一个，返回第几个等于 key 是由整个数组的长度和其它数组中的数字的大小所决定的，代码如下：

```cpp
int erfen(vector<int> arr,int key){
   int L = 0,R = arr.size() - 1; //在[L,R]范围内寻找key
   int mid;
   while( L <= R)//这里一定要写成小于等于，举个最简单的例子，｛1，3，4｝寻找4，如果缺少等于就找不到
   {
     mid = L + ((R - L) >> 1);
     if(arr[mid] == key)return mid;
     if(arr[mid] > key)
       R = mid - 1;// key 在 [L,mid-1]内
     else
       L = mid + 1;
    }
        return -1;
   }
```

二、查找数组中第一个等于 key 的数字
--------------------
数组中可能有重复的 key，要找的是第一个 key 的位置，相比于第一种方法做了改进，第一种情况的目标是寻找到一个等于 key 的数就可以

1、找到一个等于 key 的数，并且它的前面没有等于 key 的数了。举个例子：1，2，3，5，6，6，6，6，6，6（key=6）. 假设目前 L 指向 0，R 指向 9，mid 指向 4，那么已经找到了 key 值，但是根据算法，R=mid-1，R 等于 3，然后继续进行循环，由于现在没有另外一个 key 了，必定是每次循环结果都是 L=mid+1, 所以最后一次循环输入必然是 L=R=3，会执行 L=mid+1=4，不满足 L<=R, 输出 L 为 4，得到最终结果。

2、找到一个等于 key 的数，但是它的前面还有等于 key 的数。依然举例：1，2，3，5，6，6，6，6，6，6，6（key=6）. 假设目前 L 指向 0，R 指向 10，mid 指向 5，那么已经找到了 key 值，但是根据程序，R=mid-1，R 等于 4，然后 L 会一直加到 4，最后输出 L=4，依然可以得到正确答案。

3，假如数组中不存在 key，那么输出条件的 `arr[L] == key` 就不会满足，输出的依然是 - 1；

总结来说就是这个算法保证了 L 只会指向第一个等于 key 的值，在 key 存在的情况下。

```cpp
/**查找第一个与key相等的元素的下标，　如果不存在返回-1　*/
     int erfenfirstEqual(vector<int> arr,int key){
        int L = 0, R = arr.size() - 1; //在[L,R]查找第一个>=key的
        int mid;
        while( L <= R){
            mid = L + ((R - L) >> 1);
            if(arr[mid] >= key)
                R = mid - 1;
            else
                L = mid + 1;
        }
        if(L < arr.size() && arr[L] == key)
            return L;
        return -1;
    }
```

三、查找数组中最后一个等于 key 的数字
---------------------

和第二种情况原理是一样的，将 >= 换成了 <=, 将 R=mid-1 改成了 L=mid+1，这代表了整个寻找过程在不断的往后移动，和第二种情况往前移动相反，同理保证 R 只会指向最后一个存在的 key，不存在的情况下返回 - 1。

```cpp
/**查找第一个大于等于key的元素的下标*/
     int erfenlasteuual(vector<int> arr,int key){
        int L = 0, R = arr.size() - 1;
        int mid;
        while( L <= R){
           mid = L + ((R - L) >> 1);
            if(arr[mid] <= key)
                L = mid + 1;
            else
                R = mid - 1;
        }
        if(R >= 0 && arr[R] == key)
            return R;
        return -1;
    }
```

四、查找数组中第一个大于等于 key 的数字
----------------------

和第二种情况类似，第二种情况是寻找第一个等于 key 的数，如果没有就返回 - 1，这里是返回第一个等于 key 的数，如果没有等于 key 的数，返回第一个大于 key 的数，如果没有大于 key 的数，那么返回 - 1.

可以直接在第二种情况的代码下修改，修改` if(L < arr.size()&& arr[L]== key)` 为` if(L < arr.size())`，因为如果没有等于 key 的数，那么就直接返回 L 就可以了. L 有几种情况，第一个是 L 没有超过数组的范围，那么返回的就是正确的结果，如果 L>=arr.size()，那么说明整个数组都小于 key，直接返回 - 1. 原理是这样的，如果数组中有 key 的情况下，那么最后按照第二种情况的思想，会返回正确的答案，也就是第一个等于 key 的数字下标，现在主要讨论的是没有 key 的情况下，依然是分为三种情况：

1、所有元素大于 key，那么 L 一直不会变化的，因为不会运行到 L=mid+1 这一条分支，最后返回 0，答案正确。

2、所有元素小于 key，那么 R 肯定是不会变化的，因为不会运行到 R=mid-1，那么最后一次循环肯定就是当 L 等于 R 的时候，依然还是走了 L=mid+1 着一个分支，此时的 mid 为 arr.size()-1，因为 R 是不会变的，R 最开始是 arr.size()-1, 最后就有 L=R+1=mid+1=arr.size(). 返回 arr.size(). 答案正确.

3、不存在 key，但是数组元素有比 key 大的，有比 key 小的，这种情况下，R 可能有两种指向，指向最后一个小于 key 的数，指向第一个大于 key 的数 (因为二分法的性质决定的)，不可能再往前或者往后指了，但是最后的跳出循环的条件必然是 L 等于 R，那么如果指向小于 key 的数，跳出循环前做 L=mid+1，或者指向大于 key，跳出循环前做 R=mid-1，结果都是正确的。

```cpp
int erfenfirstlargeEqual(vector<int> arr,int key){
        int L = 0, R = arr.size() - 1; //在[L,R]查找第一个>=key的
        int mid;
        while( L <= R){
            mid = L + ((R - L) >> 1);
            if(arr[mid] >= key)
                R = mid - 1;
            else
                L = mid + 1;
        }
        if(L < arr.size())
            return L;
        return -1;
    }
```

五、查找数组中最后一个小于等于 key 的数字
-----------------------

查找最后一个大于等于 key 的数字没有意义，直接输出数组的最后一个元素判断是否大于 key 就行了，所以不用二分。原理和第四种情况一样，有不同的地方在于，因为 R 只有等于 - 1 这一种情况超出数组范围，而能造成这种情况的前提就是数组中确实没有小于等于 key 的数字，所以直接输出 R 就行了，这个是第四种情况的镜像。

```cpp
int erfenlastSmallEqual(vector<int> arr,int key){
        int L = 0, R = arr.size() - 1;
        int mid;
        while( L <= R){
            mid = L + ((R - L) >> 1);
            if(arr[mid] <= key)
                L = mid + 1;
            else
                R = mid - 1;
        }
        return R;
    }
```

六、查找数组中第一个大于 key 的数字
--------------------

这个和第二种和第四种情况的不同在于:` if(arr[mid] >= key)` 改成了` if(arr[mid] > key)`，因为不是要寻找等 key 的；而是要寻找大于 key 的，但是因为是寻找第一个大于的，所以依然找到后不能直接返回，和普通的二分法有点像，但是没有等于 key 跳出这条分支，最后依然是返回 L，依然是分三种情况：

1、全部小于 key，那么 R 不会变，直到最后都不会变，所以最后返回的 L=mid+1=R+1=arr.size()-1+1=arr.size()

2、全部大于 key，那么 L 不会变，最后返回 L，L=0

3、有大于的，有小于的，那么一样的道理，因为在等于 key 的时候是选择做 L=mid-1，所以 R 最小只能指向最后一个等于 key 或者最后一个小于 key 的值（无 key 的情况下），那么最后的结果是返回 L=R+1，依然是返回了第一个大于 key 的数。

```cpp
/**查找第一个大于key的元素的下标 */
    int erfenfirstLarge(vector<int> arr,int key){
        int L = 0,R = arr.size() - 1;
        int mid;
        while(L <= R){
            mid = L + ((R - L) >> 1);
            if(arr[mid] > key)
                R = mid - 1;
            else
                L = mid + 1;
        }
        return L;
    }
```

七、查找数组中最后一个小于 key 的数字
---------------------

和上一个问题是镜像问题，同样的原理，整个对比过程在不断往后移动。

```cpp
int erfenlastSmall(vector<int> arr,int key){
        int L = 0, R = arr.size() - 1;
        int mid;
        while(L <= R){
            mid =  L + ((R - L) >> 1);
            if(arr[mid] < key)
                L = mid + 1;
            else
                R = mid - 1;
        }
        return R;
    }
```