### 问题 C: 最大公因子

时间限制: 1.000 Sec  内存限制: 512 MB  

#### 题目描述

给定正整数 N 与 K ，请求出若将 N 拆成 K 个正整数的和，这 K 个数的最大公因子最大可以是多少。  

#### 输入

输入包含多个测试数据，第一行为 T 代表测试数据的个数。  
接着 T 行每行包含两个正整数 N 与 K ，意义请参考题目叙述。  
  

#### 输出

输出 T 行，每行有一个正整数代表每个测试数据中，最大公因子最大可能为多少。  

#### 样例输入 Copy

2
4 2
5 1

#### 样例输出 Copy

2
5

#### 提示

【样例解释】  
第一个样例中，可以将 4 拆成 2 + 2 ，这样最大公因子为 2 。  
第二个样例种，只有一种拆法将 5 拆成 5 ，因此最大公因子为 5 。  
【数据规模】  
$1 ≤ T ≤ 20$  
$1 ≤ K ≤ N ≤ 10^{12}$

## 分析
把一个数分为k个数求最大公因子，这个公因子肯定也是n的因子，所以要从n的因子中找，因为对称性，只用找sqrt（n）就可以找到所有的因子，再在其中找大于等于k的因子，那么最大公因子就是n/num

## 参考代码：
```cpp

#include<bits/stdc++.h>
using namespace std;
#define de(x) cout << (#x) << " = " << (x) << endl;
#define de2(x, y) cout << (#x) << " , " << (#y) << " = " << (x) << " ~ " << (y) << endl;
#define endl '\n'
#define f(n) for(int i = 0;i < n; ++i)
#define ff(i, a, b) for(int i = a; i < b; ++i)
typedef long long ll;
typedef unsigned long long ull;
#define int long long 

const int N = 1e7;
int v[N];
void solve() {
	int n, k;
	cin >> n >> k;

	int idx = 0;

	for(int i = 1;i *i <= n; ++i) {
		if(n % i == 0) {
			v[++idx] = i;
			v[++idx] = n/i;
		}
	}

	sort(v+1, v+1+idx);

	auto it = lower_bound(v+1, v+1+idx, k) - v;
	cout << n / v[it] << endl;

	
}

signed main() {
//	freopen("an", "r", stdin);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	while(n--) solve();

	return 0;
}
```