1. 不拘一格地使用伪代码来思考和描述算法是一种值得推荐的做法。  
2. 把伪代码改写成代码时， 一般先选择较为容易的任务来完成  
3. 由于误差的影响， 整数1变成了0.9999999999， floor的结果会是0而不是1。 为了减小误差的影响， 一般改成四舍五入， 即floor（ x＋ 0.5） (2)。 如果难以理解， 可以想象成在数轴上把一个单位区间往左移动0.5个单位的距离。 floor（ x） 等于1的区间为\[1， 2） ， 而floor（ x＋ 0.5） 等于1的区间为\[0.5， 1.5）  
4. C99并没有规定int类型的确切大小， 但在当前流行的竞赛平台中， int都是32位整数， 范围是-2147483648～ 2147483647。  
5. 只有算完一项之后才知道它是否小于10-6。 也就是说， 循环终止判断是在计算之后， 而不是计算之前。这样的情况很适合使用do-while循环。
6. 要计算只包含加法、 减法和乘法的整数表达式除以正整数n的余数， 可以在每步计算之后对n取余， 结果不变
7. 可以使用time.h和clock（ ） 函数获得程序运行时间。 常数CLOCKS_PER_SEC和操作系统相关， 请不要直接使用clock（ ） 的返回值， 而应总是除以CLOCKS_PER_SEC。输出的Time used居然不是0！ 其原因在于， 键盘输入的时间也被计算在内——这的确是程序启动之后才进行的。 为了避免输入数据的时间影响测试结果， 可使用一种称为“管道”的小技巧： 在Windows命令行下执行echo 20|abc， 操作系统会自动把20输入， 其中abc是程序名
8. 在Windows下， 输入完毕后先按Enter键， 再按Ctrl＋ Z键， 最后再按Enter键， 即可结束输入。 在Linux下， 输入完毕后按Ctrl＋ D键即可结束输入。
9. 使用文件最简单的方法是使用输入输出重定向， 只需在main函数的入口处加入以下两条

	语句：

	`freopen("input.txt", "r", stdin);

	freopen("output.txt", "w", stdout);`

10. 在多数据的题目中， 一个常见的错误是： 在计算完一组数据后某些变量没有重置， 影响到下组数据的求解。
11. `memset（ a， 0， sizeof（ a） ）` ”的作用是把数组a清零，
12. 首先， 赋值x=0和y=n-1后马上要把它们 作为数组a的下标， 因此可以合并完成； tot和a[0][n-1]都要赋值1， 也可以合并完成。 这样， 就用一条语句完成了多件事情， 而且并没有牺牲程序的可读性——这段代码的含义显而易见。`tot = a[x=0][y=n-1] = 1;`
13. 在“scanf("%s", s)”中， 不要在s前面加上“&”符号。 如果是字符串数组`char s[maxn] [maxl]`， 可以用“`scanf("%s", s[i])`”读取第i个字符串。 注意， “scanf("%s", s)”遇到空白字符会停下来。
14. C语言中的字符串是以“\0”结尾的字符数组， 可以用strlen(s)返回字符串s中

15. 结束标记之前的字符个数。 字符串中的各个字符是`s[0], s[1],…,s[strlen(s)-1]`。
	fgets(buf, maxn, fin)"将读取完整的一行放在字符数组buf中。 应当保证buf足够存放下文件的一行内容。 除了在文件结束前没有遇到“\n”这种特殊情况外， buf总是以“\n”结尾。 当一个字符都没有读到时， fgets返回NULL。
16. 提示3-19： 善用常量数组往往能简化代码。 定义常量数组时无须指明大小， 编译器会计算。
17. - `sprintf(buf, "格式字符串", 变量1, 变量2, ...);`作用是**格式化字符串并存入字符数组**
18. 语句“printf("%d %o %x\n", a)”将把整数a分别按照十进制、 八进制和十六进制输出。
19. n太大时的理由则不明显： i*i可能会溢出！ 如果n是一个接近int的最大值的素数， 则当循环到i=46340时， i*i=2147395600<n； 但i=46341时， i*i=2147488281， 超过了int的最大值， 溢出变成负数， 仍然满足i*i<n。 若n不是太大， 可能出现101128442溢出后等于2147483280， 终止循环；但如果n= 2147483647， 循环将一直进行下去。修正`int m = floor(sqrt(n) + 0.5); for(int i = 2; i <= m; i++)`, + 0.5 防止误差
20. 这里的新内容是指向常数的“万能”的指针： const void *， 它可以通过强制类型转化变成任意类型的指针。 对于本题来说， 排序的对象是整型数组， 因此要这样写：

	`int cmp ( const void *a , const void *b ) {
	
	return *(int *)a - *(int *)b;}`
21. 在可执行文件中， 正文段（ Text Segment） 用于储存指令， 数据段（ Data Segment） 用于储存已初始化的全局变量， BSS段（ BSS Segment） 用于储存未赋值的全局变量所需的空间。
22. 在运行时， 程序会动态创建一个堆栈段， 里面存放着调用栈， 因此保存着函数的调用关系和局部变量。
23. 一般而言， 程序不是直接从第一行开始写到最后一行结束， 而是遵循两种常见的顺序之一： 自顶向下和自底向上。 什么叫自顶向下呢？ 简单地说， 就是先写框架， 再写细节。 实际上， 之前已经用过这个方法了， 就是先写“伪代码”， 然后转化成实际的代码。 有了“函数”这个工具之后， 可以更好地贯彻这个方法： 先写主程序， 包括对函数的调用， 再实现函数本身。 自底向上和这个顺序相反， 是先写函数， 再写主程序。 对于编写复杂软件来说， 自底向下的构建方式有它独特的优势(8)。 但在算法竞赛中， 这样做的选手并不多见(9)。
24. 1-n,怎么通过%取到,只要 (k - 1)%n + 1;
25. 局部变量是在栈中， 函数执行完毕后， 局部变量就失效了。 严格地讲， 指针里保存的地址仍然存在， 但不再属于那个局部变量了
26. 



