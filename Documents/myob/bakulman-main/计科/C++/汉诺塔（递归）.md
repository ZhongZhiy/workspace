### 问题 N: Tower of Hanoi



#### 题目描述

The Tower of Hanoi game consists of three stacks (left, middle and right) and n round disks of different sizes. Initially, the left stack has all the disks, in increasing order of size from top to bottom.   
The goal is to move all the disks to the right stack using the middle stack. On each move you can move the uppermost disk from a stack to another stack. In addition, it is not allowed to place a larger disk on a smaller disk.  
Your task is to find a solution that minimizes the number of moves.  

#### 输入

The only input line has an integer n（1 ≤ n ≤ 16）: the number of disks.

#### 输出

First print an integer k: the minimum number of moves.  
After this, print k lines that describe the moves. Each line has two integers a and b: you move a disk from stack a to stack b.  

#### 样例输入 Copy

2

#### 样例输出 Copy

3
1 2
1 3
2 3


## 题解
使用递归求解汉诺塔问题，先算最小交换次数，根据递推公式$a_{n}=2a_{n-1}+1$，可得到$a_{n}=2^{n}-1$次
然后是求解处理步骤：
**解题思路 (递归)**

汉诺塔问题是递归的经典范例。将 n 个盘子从源柱子 (source) 移动到目标柱子 (destination)，借助辅助柱子 (auxiliary) 的最少步骤如下：

1. **将 n-1 个较小的盘子** 从 `source` 移动到 `auxiliary`，借助 `destination` 作为辅助。
2. **将第 n 个（最大的）盘子** 从 `source` 直接移动到 `destination`。
3. **将 n-1 个较小的盘子** 从 `auxiliary` 移动到 `destination`，借助 `source` 作为辅助。

**基本情况:** 当 n = 0 时，不需要移动。

**移动次数:** 设 M(n) 为移动 n 个盘子所需的最少次数。 $M(n) = M(n-1) + 1 + M(n-1) = 2 * M(n-1) + 1$ ,$M(0) = 0$ 解这个递推关系得到 $M(n) = 2^n - 1$。

**实现细节:** 我们可以编写一个递归函数 `hanoi(n, source, destination, auxiliary)` 来执行上述步骤。为了记录移动过程，我们可以使用一个 `std::vector<std::pair<int, int>>` 来存储每一步的移动（从哪个柱子到哪个柱子）。


注意别忘了基本递归思路，先找到结束条件

代码：
```cpp
#include <iostream>
#include <vector>
#include <cmath> // for pow
#include <utility> // for std::pair

// 用于存储移动步骤的向量
std::vector<std::pair<int, int>> moves;

// 递归函数解决汉诺塔问题
// n: 当前要移动的盘子数量
// source: 源柱子编号
// destination: 目标柱子编号
// auxiliary: 辅助柱子编号
void solve_hanoi(int n, int source, int destination, int auxiliary) {
    // 基本情况：没有盘子需要移动
    if (n == 0) {
        return;
    }

    // 1. 将 n-1 个盘子从 source 移动到 auxiliary，使用 destination 作为辅助
    solve_hanoi(n - 1, source, auxiliary, destination);

    // 2. 将第 n 个盘子从 source 移动到 destination
    moves.push_back({source, destination});

    // 3. 将 n-1 个盘子从 auxiliary 移动到 destination，使用 source 作为辅助
    solve_hanoi(n - 1, auxiliary, destination, source);
}

int main() {
    // 加速输入输出
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    // 计算最少移动次数 k = 2^n - 1
    // 使用 (1 << n) - 1 比 pow 更高效且避免浮点数问题
    int k = (1 << n) - 1;
    // 或者 long long k = (1LL << n) - 1; 如果 n 可能更大

    std::cout << k << "\n";

    // 调用递归函数开始解决问题
    // 初始状态：n 个盘子，从柱子 1 移动到柱子 3，使用柱子 2 作为辅助
    solve_hanoi(n, 1, 3, 2);

    // 输出所有记录的移动步骤
    for (const auto& move : moves) {
        std::cout << move.first << " " << move.second << "\n";
    }

    return 0;
}
```