## 邻接表
1. 数组 > 单链表 : 邻接表 ( 存储图和树 )
2. 双链表 : 优化题


```cpp
int e[N],ne[N] //下标关联,value 和 下一个元
素

const int N = 100005;
// head 链表头节点的下标
// e[i]节点i的值
//ne[i]表示节点i的next指针是多少
//idx 用到哪个点
int head, e[N], en[N], idx;

void init()
{
	head = -1;
	idx = 0;
}

//插入链表
void add_to_head(int x)
{
	e[idx] = x; //idx就是新的点可以用的下标
	ne[idx] = head;
	head = idx;
	idx++;
}

void add_to_k(int k, int x)
{
	e[k] = x;
	en[idx] = en[k];
	ne[k] = idx;
	idx++;
}
// 把下标为k的点后的点 
void remove(int k)
{
	ne[k] = ne[ne[k]];
}
```

双链表
```cpp

int e[N], l[N], r[N];
void init()
{
	//0和1节点
	l[1] = 0; //指向左边
	r[0] = 1; //指向右边
	idx = 2;
}
// k的右边插入  //从左边就传入l[k]
void add_to_k(int k, int x)
{
	e[inx] = x;
	r[idx] = r[k];
	l[idx] = k;
	l[r[k]] = idx;
	r[k] = idx; 
}

// 删除第k个点
void remove(int k)
{
	r[l[k]] = r[k];
	l[r[k]] = l[k]; 
}
```
## 栈
栈 : 先进后出
队列 : 先进先出

```cpp
int stk[N], tt = 0;
//插入
stk[++t] = x;

//弹出
t--;

// 判断是否为空
if(tt == 0) empty
else not empty

//栈顶
stk[tt];
```


## 队列
```cpp
int q[N], hh, tt = -1;  //初始
//插入
q[++tt] = x;
//弹出
hh++;

   头hh ........tt尾
//判断空
if(hh <= tt) not empty
else empty

//队列头
q[hh]

```

## 单调栈
找到左边最近的一个数

eg:
    3,   4,    2,   7,   5;
ans : -1   3    -1   2    2
较小的在右面的话左边的较大元素就不会作为答案,前面逆序就弹出前面较大的数, 保持栈单调, 查找也是从栈顶检查,栈顶元素比这个元素大,构成逆序,弹出
```cpp
	int n;
	cin >> n;
	for(int i = 0;i < n;++i)
	{
		int x;
		cin >> x;
		while(tt && stk[tt] > x) t--;
		if(tt) cout << stk[tt] << endl;
		else cout << -1 <<  endl;
	}
```


### 单调队列(先把朴素做法搞清楚,再看哪些元素是没有用的,再看有没有单调性)
求滑动窗口长度为k的最大值,最小值
手动快


## KMP

```cpp
 //朴素做法
 s[N],p[M];
 for(int i = 1;i <= n;++i)
{
	flag = true;
	for(int j = 1;j <= m;++j)
		if(s[i] != p[j])
		{
			flag = false;
			break;
		}
}
```