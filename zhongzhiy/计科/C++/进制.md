10进制转R进制 : 除R取余数,再倒过来
R进制转10进制 : 按权展开 $3506_8 = 6 \times 8^0 + 0 \times 8^1 + 5 \times 8^3 + 3 \times 8^3 = (1862)_10$ 8 4 2 1 可以15内快速转换

2进制转8进制16进制 : 8进制=3位2进制 , 16进制 = 4位16进制 , 不够补0

注意
1. 首位为0
2. 结果为0
3. 中间为0, 添加0000、



## 递归
自我调用, 原理A(n)可以通过A(n-1)求解
过程: 找出规律 , 函数调用自己求解前面的项, 交代起始项, 让递归能够停止

递归重要思想：
 既然函数fun()能够求第n项，那么它就能求第n-1项，也能求第n+1项；
 既然函数fun()能够解决一个问题的第n步，就能解决第n-1步，也能解决第n+1步


原理：
1、每个函数运行时会生成一个独立的内存，来存储函数内部定义的变
量，因此函数互相看不到对方内部定义的变量名，也不会出现变量名
冲突的情况。
2、向函数中传递整数，本质是将整数的值拷贝给函数；向函数中传递
数组，本质是将数组的地址拷贝给函数；


二分
思想：
先找到数组的中间位置mid，判断
（1)如果要找的数`x=a=[mid]`，找到了，mid就是位置
（2如果要找的数`x>a[mid]`，说明要找的数在后一半，递归在后一半找
（3)如果要找的数`x<a[mid]`，说明要找的数在前一半，递归在前一半找
在下标为Left~right之间的范围内找数，mid=（Left+right)/2
当left<=right就一直找，直到找到了，或者Leftright（找不到）

二分查找左边界的注意点：<
（1）二分查找，如果`a[mid]==x`，还要向左侧看，判断左侧是否还是x；
（2）找左边界的本质：找数组中第一个>=x的元素的位置；
（3）找到位置L之后，要判断`a[L]==x`（注意，如果有负数，找O，要判断L在下标范围内）；

左边界 : 
```cpp
if(v[mid] >= x)  
{  
    r = mid -1;  
}  
else if(v[mid] < x)  
{  
    l = mid + 1;  
}
return l;//下标第一个>=x的元素的位置
```
右边界 : 
```cpp
if(v[mid] > x)  
{  
    r = mid -1;  
}  
else if(v[mid] <= x)  
{  
    l = mid + 1;  
}
//l就是数组中第一个>元素x的位置
if(a[l-1] == x) return 1-1;
else return -1;
```

### **1. 输出左边界（`left`）的场景**

**左边界用于查找“满足条件的第一个位置”**。通常适用于以下情况：

- 查找数组中**第一个大于等于目标值**的位置。
- 查找范围的**最小值**。

#### **特点：**

- 循环结束时，`left` 指向**第一个满足条件的位置**。
- 一般需要初始化 `left = 0`，`right = size`right = size - 1`，并在条件成立时更新 `right = mid - 1

### **2. 输出右边界（`right`）的场景**

**右边界用于查找“满足条件的最后一个位置”**。通常适用于以下情况：

- 查找数组中**最后一个小于等于目标值**的位置。
- 查找范围的**最大值**。

#### **特点：**

- 循环结束时，`right` 指向**最后一个满足条件的位置**。
- 一般需要初始化 `left = 0`，`right = size - 1`，并在条件成立时更新 `left = mid + 1`。


### **更深入的理解**

4. **左边界适合“找第一个”**：
    
    - 场景：寻找第一个大于等于目标值的索引。
    - 假设 `v = [1, 3, 3, 5, 7]`，目标值 `x = 3`。
        - 左边界指向第一个 `3` 的位置（索引 `1`）。
5. **右边界适合“找最后一个”**：
    
    - 场景：寻找最后一个小于等于目标值的索引。
    - 假设 `v = [1, 3, 3, 5, 7]`，目标值 `x = 3`。
        - 右边界指向最后一个 `3` 的位置（索引 `2`）。

 13.2二分函数←

  一，binary_searchO：二分查找函数
 1、 `binary_search(a+begin, a+end, x, cmp)` :
 函数含义：在a数组的下标为\[begin，end)区间内，按照cmp的排序规则，找元素x
到返回true，找不到返回false。

 注意点：
 （1）查找区间是左闭右开的：\[begin，end），不包含结束位置；
 （2）排序规则**cmp不是必须**的，但**查找时的排序规则，必须和排序的规则**是一致的；
  （3）等于的含义：a等于b等价于a在b的前面，b在a的前面都不成立


   二，lower_bound O和upper_boundO
  1、lower_boundO：二分查找左边界
 ` T* lower_bound(a+begin.a+end, x, cmp) ;`
  函数含义：在a数组的下标为\[begin，end)区间内，按照cmp的排序规则，找元素x的
左边界（第一个>元素的x的位置），**返回位置指针**；
  注意点：
  （1）基本注意点同binary_search；
   （2）此处返回的不是下标的值，而是返回指针：T*p；
  （3）如果找不到符合条件的元素位置，指向下标为end的元素位置；
  找**该元素下标**就要返回的指针减去首元素的指针

Havel-Hakimi定理

由非负整数组成的非增序列S：d，d²，··，d(n≥2,d,≥1)
是可图的，当且仅当序列Si:d²-1,ds-1，··，dd1+1-1,dd1+2，···，
d,是可图的。
其中，序列S,中有n-1个非负整数，S序列中d,后的前di个度
数(即d～dd1+1)减1后构成Si中的前di个数。

Dilworth定理:
对于一个偏序集 <最少链划分数等于最长反链长度。

结论：本题本质一一求最长上升子序列的长度！
一言以蔽之，偏序集能划分成的最少的全序集个数等于最大反链的元素个数



应用上的区别：

BFS：对于解决最短或最少问题特别有效（因为BFS只要访问到某
 个点，一定是最短路径到达的点），而且寻找深度小，但缺点是
 内存耗费量大（需要开大量的数组单元用来存储状态）。

 DFS：对于解决遍历求所有路径问题有效，对于问题搜索深度小
 的时候处理速度迅速，然而在深度很大的情况下效率不高。





### 组合博弈
必败 (必胜) 点属性
(1) 所有终结点是必败点 （P点）;
(2）从任何必胜点（N点操作，至少有一种方法可以进入必败点（P点）
(3)无论如何操作 从必败点（P点）都只能进入必胜点（N点）

取子游戏算法实现

步骤1：将所有终结位置标记为必败点 (P点) 步骤2:将所有一步操作能进入必败点（P点）的位置标记为必胜点(N点) 
步骤3:如果从某个点开始的所有一步操作都只能进入必胜点（N点），则将该点标记为必败点（P点）；
步骤4:如果在步骤3未能找到新的必败（P点），则算法终止；否则，返回到步骤2。



## 拓扑排序

从入度为0的点找,找到后删除,再找
![[Pasted image 20250131152830.png]]