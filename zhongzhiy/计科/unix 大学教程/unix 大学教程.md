## 论点
大量的用户妨碍未来的发展, 这是软件设计的一个重要的长远原则，可是大多数人(大多数公司)没有领会掌握。

X程序员所展现的是，当您开发一个重要的产品而且希望它能持续很长一段时间时， 在开头花大量的时间是值得的。一个灵活的、深思熟虑的设计可以使产品的生命力持久。 这也是一个编程原则，但是许多人没有领会到这一点。

当使用主要是为了容易学习而设计的工具时，我们最终会觉得系统由计算机控制。当 使用设计良好、功能强大但需要花费时间学习的工具时，我们最终会觉得系统由用户控制。 Unix就是这种情况。

我们可以使用7个终端其中一个图形终端，使用`Alt+ctrl + F1`来选择

切换账户命令：`su weekly`，不切换环境，
切换环境`su - weekly`

要修改程序设置就是改它的配置文件
使用`less`阅读文档
>一旦 less 启动，它将向您显示第一屏的信息。如果要向前移动，可以按`<Space>`键; 向移动，按`<b>`键；查看帮助，按`<h>`键；退出less，按`<q>`键。这些就是您现在所需的 全部技能。vim操作一样应该

> /boot/grub/menu.lst：关于计算机上可以引导的操作系统的信息。
>  /etc/hosts：系统已知的一列主机名称和IP地址。 /etc/inittab：不同运行级别的定义。 /etc/passwd：每个用户标识的基本信息(实际口令是加密的，而且保存在其他地方)。 /etc/profile：当一个用户标识登录时，系统自动执行的命令。 /etc/samba/smb.conf:Samba 的配置信息，Samba 是一个允许 Unix 系统和 Windows 系统共享文件和打印机的工具。

## 系统的关机与重启
运行级别上，0就是关机，6就是重启
修改运行级别`init`
eg:
>sudo init 6

使用`reboot`重启
使用`shutdown now`关机
都可以切换运行级别

##  用户使用
**用户id（userid）**
显示用户的命令：`w`或`who`,`whoami`
查看上一次登陆时间`last`

## 超级用户\#

## 运行级别
在`/etc/inittab`中改`initdefault`自地动设置
0 关机
1单用户CLI
3多用户CLI
5多用户GUI
6重启

## 虚拟控制台
使用`ctrl+alt+f123456`切换虚拟控制台，7是GUI



## x windou
选中后点击中键粘贴
双击选中单词，三击选中一行

## su（substitute userid）命令
`su mmuser`切换为目标账户
`su - mmuser`切换用户和环境
`id`显示当前userid

## 配置文件
使用`less`浏览配置文件

## 终端
符号tty
使用的终端一般就四种：xterm
可以使用`echo $TERM`查看当点的终端种类
键盘映射`^C`映射到了`intr`中断命令
`^W`删除单词
`^U`删除整行
backspace映射到`^H`
	讲了一些键盘一些按键的早期历史

和intr差不多的停止命令stop映射到了`^\`
`^S`暂停程序
`^Q`继续程序
`^D`发送eof信号，shell程序也可以使用`^D`来eof,有一些程序是封闭了


`stty`设置终端
`stty -a`所有终端设置
`ssty earse ^H`修改映射


## **return总结**

为了便于理解，文中给出了以下小结：

1. 返回字符 = **^M** 。
2. 换行字符 = 新行字符 = **^J** 。
3. 一般而言，每行文本必须以一个新行字符 (**^J** ) 结束。
4. 当按下 `<Return>` 键时，将发送一个返回字符 (**^M** )，Unix 自动将其转换为新行字符 (**^J** )。
5. 在终端上显示数据时，每行必须以字符序列 “返回 + 换行” (**^M^J** ) 结束。因此，当数据从文件发送到终端显示时，Unix 自动将每行末尾的新行字符 (**^J** ) 改变为返回字符 (**^M** ) + 换行字符 (**^J** )。
## 一些程序
`which`以及`type`
一些程序可以通过`quit`或者`q`或者`^D`,`^C`退出
计算器`bc`功能强大，具有函数编程功能
日历`cal 9 2025`
`uptime`查看计算机运行时间
`uname`显示计算机系统名称
`hostname`显示计算机名称
`whoami`显示userid
`w`查看有谁在做什么
`who`查看有谁在线
`lock`临时上锁
`leave`提醒离开
`echo`把多行输入合并为一行输出

## 联机手册
`man`使用h查看帮助，使用`!date`可以使用shell命令
手册有8节分类
常常有引用可以使用man查看

| 标头          | 含义          |
| ----------- | ----------- |
| Name        | 命令的名称和用途    |
| Synopsis    | 命令用法        |
| Description | 完整描述        |
| Environment | 命令使用的环境变量   |
| Author      | 程序员名字       |
| File        | 对该命令重要的文件列表 |
| See also    | 查看相关信息的位置   |
| Diagnistics | 可能的错误和警告    |
| Bugs        | 错误，缺点，警告    |
|             |             |
简化`man -f`就等于`whatis`

搜索关键字`man -k`就等于`apropos`

## 使用info
使用H查看命令操作
`pd` or `space`是下一屏
`pu` or `backspace`是 上一屏
节点数
![|500x413](unix%20大学教程-1751114050127.webp)

## 命令
命令名称  选项   参数
选项有`-h`和长的`--help`,选项必须位于参数之前
命令规则
1. 方括号中为可选的
2. 不在方括号的为必选
3. 黑体必须按照原样输入
4. 斜体必须替代（斜体有时候是下划线）
5. 接省略号的参数可以有多个
6. 如果一个单独的选项和一个参数组合在一起，那么该选项就必须接一个这个参数
7. 使用|分开的参数表示可以选择一个

## shell
有很多种shell
查看系统安装的shell`echo /etc/shells`,查看当前的shell使用`echo $SHELL`
暂时更换shell就直接键入
永久改变登陆的shell需要使用`chsh`

变量，就是存储数据的主体
区分shell变量，是局部变量
而环境变量是全局变量，bash中的变量就只有**shell变量**和**同时是shell变量和环境变量**
csh绑定了5个特定的变量，会随着shell修改分别是cwd,home, path, term, user

显示环境变量`env` or  `printenv`
排序输出`env | sort | less`

| 变量       | 含义      |
| -------- | ------- |
| HOME     | home目录  |
| HOSTNAME | 计算机名称   |
| HOSTTPYE | 计算机类型   |
| LOGNAME  | 当前用户标识  |
| PATH     | 搜索程序的目录 |
| PWD      | 当前目录    |
| TERM     | 终端类型    |
| USER     | 当前用户标识  |

使用`set`可以列出所有的shell变量

## 使用echo或者pirnt显示变量

bash中：
设置变量`NAME=value`
将变量设置为环境变量`export NAME`
同时操作`export NAME=value`

复位变量`unset NAME`

csh中：使用`setenv`,`set`,`unset`等等
## 交互式shell选项
使用`set -o name`开启shell选项
使用`set +o name`关闭选项
![|500x713](unix%20大学教程-1751178989032.webp)


## 元字符
引用使用`\`或者单引号，双引号不转义`$`,`\`,\`
\甚至可以转义\<return>
单引号在bash也可以

## 有内置命令和外置命令
使用`type common`检查是否是内部命令
还有使用`help`直接查看内置命令-s看语法
外部命令都是通过PATH来搜索的，shell会按照顺序依次查找
添加路径`export PATH="$PATH:$HOME/bin"这样就把目录添加到了PATH的末尾

shell提示符号储存在变量PS1中，可以修改
可以修改成一些有用的东西`PS1="${USER}$ "`之类的，还有计算机名称，home目录，运行时间，等等


使用反引号来替换命令'basename $SHELL'


## 历史列表
使用`history`查看
使用`!num`或者`fc -s num`来调用
替换/修改命令使用`fc -s file=replacefile number`或者`!number:s/file/replacefile/`
替换部分`fc -s a=e number`或者`^a^e`
历史列表大小存在变量HISTSIZE中

## 删除前
使用`rm`前应该使用`ls`检查一遍

## 自动补全
补全命令，变量（$开头），文件名，用户名（～），主机名

## 创建别名
`alias name=common`
解除别名`unalias name`
查看别名`alias name`查看所有别名`alias`

运行非别名使用`\ls`

## 初始化
登陆shell执行登陆文件和环境文件
非登陆shell执行环境文件

bash登陆文件为.profile  环境文件为.bashrc    注销文件为.bash_logout
csh登陆文件为.login  环境文件为.cshrc/.tcshrc  注销文件为.logout
遵守POSIX的ksh和bash的登陆文件为.profile  环境文件为$ENV变量可以自定义
登陆文件有两个作用为：设置环境以及初始化工作会话
含有1.创建和修改环境变量的命令 2.执行所有一次性操作命令
环境文件设置不能在环境中保存的自定义项，特别是shell选项，别名，和函数

## 重定向
使用`>`重定向到一个文件，创建或覆盖原本文件，使用`>>`是追加文件
shell选型noclobber可以防止覆盖原本文件
使用`>|`来暂时忽略noclobber,即使有原本文件也覆盖

bash中**文件描述符**就是每个输入源和输出对象拥有的唯一数字标识
bash默认0代表标准输入，1代表标准输出，2代表标准错误，因此可以这三者可以分流
`command 0< inputfile`
其中`0<`和`<`一样，`1>`和`>`一样，但是标准错误流只能使用`2>`

重定向到同一个文件`command 1> output 2>&1`搞不懂
## 子shell
子shell会继承父shell的环境，但是子shell做的修改不会保留
使用`(cd command)`就是可以在不打开子shell的情况下运行zishell命令

## 抛弃输出
只用把输出重定向到`/dev/null`就可以了
`update >/dev/null 2>&1`抛弃全部输出

![|500x221](unix%20大学教程-1751262295730.webp)

## 管道
将一个程序的标准输出作为另外一个程序的标准输入
还可以把标准错误一起输出`command1 2>&1 | command2`

管道分流使用`tee`就是同时发送一份到文件和标准输出
`command1 | tee file | command2`
可以使用`tee -a file`追加而不是创建一份文件

条件执行可以使用`&&`和`||`

## 过滤器
就是从标准输入读取数据并且向标准输出写入数据的程序
#### cat：把数据未加改变地输出到标准输出
1) 创建小文件`cat > file`
2) 追加内容 `cat >> file`
3) 显示文件`cat < file`
4) 重定向标准输入输出到复制文件
5) 可以接好几个文件连接起来`cat file1 file3  ...`把文件连接起来
语法`cat [-nbs] file`其中`-n`是编行号，`-b`是空行不编号， `-s`是压缩多个空行为一个空行

#### split划分文件
	语法`split [-d] [-a num] [-l lines] [file [prefix]]`
`-d`使用数字后缀，默认两位
`-a 3`后缀的位数
`-l 5000`每个文件包含的行数，默认1000行
`file [prefix]]`分解某个文件，分解的文件前缀为prefix

#### 反转
行反转`rev`
输出反转`tac`

输出头`head -n`
输出最后`tail -n`

删除列`colrm [[startcol] [endcol]]`

## 比较程序
`cmp file1 file2`一个字节地比较，只比较相同吗
`comm [-123] file1 file2`比较两个排序后的文件，第一列为file1特有的行，第二列是file2特有的列，123分别表示抑制第123列，可惜只能比较排序的文本行，不知道有什么用


### grep

## vi
只读打开`vim -R file`或者`view file`
数据恢复，恢复非正常关闭的数据`vim -r file`
文件保存使用`ZZ`
`～`表示空行
^I`是制表符
修改命令可以使用backspace`和`^W`删除最后一个单词，和`^U`删除一行

#### 移动
0移动到开头
$移动到非空开头
^移动到末尾

w移动到下一个单词首  W忽略标点
e移动到下一个单词尾   E
b移动到上一个单词首    B

(移动到下一个句子
) 移动到上一个句子
{ 移动到下一个段落
} 移动到上一个段落

H移动到屏幕顶部
M移动到屏幕中间
L移动到屏幕底部


`^F`下移一屏
`^B`上移一屏
`^D`下移半屏
`^U`上移半屏

跳转到刚刚的行使用双反引号
可以使用标记`ma`,标记一个a然后使用反引号或者单引号跳转到标记

使用/和？搜索，其中可以使用正则
n下一条搜索，N上一条搜索

可以使用命令模式直接跳转到指定行`:12`

使用r替换单个字符，使用R替换多个字符
使用s，删除一个字符进入插入模式
使用C替换光标到行尾的所有
替换一整行可以使用S和cc
cw替换一个单词

替换命令
`：s/word/replace/`替换当前行最后`/c`替换询问，`/g`替换全局
`:12,55s/word/replace/`替换指定范围的行，可以使用%代表全部行，1表示缓冲区第一行，$表示缓冲区的最后一行

删除
使用x删除当前字符，使用X删除左边的一个字符
D删除从当前光标到行尾的字符
dw删除后面一个单词，db删除前一个单词，d2）删除两个句子，d}删除一个段落，dG删除当前行到缓冲区末尾，dgg删除当前行到缓冲区开头
dd删除一行
还可以使用命令`:12d`删除12行，也可以删除行范围


撤销
u撤销上一个命令
U恢复当前行
.重复上一个命令

恢复删除，vim有9个删除缓冲区，使用1p可以把上次删除的粘贴到下一行，使用P粘贴到上一行，可以使用u再试试其他数字
可以组合删除和p进行交换字符单词，以及行

yank行为和d一样

改变大小写使用`～`就可以

使用set查看修改的命令
使用`set option?`显示选项的值
设置自动换行`set wrapmargin=6`,关闭就等于0就可以了
自动缩进`:set autoindent`

分割行使用`<return>`
合并行使用`3J`就合并后3行

复制`.,$：co12`复制到12行
剪切`.,$:m12`都是可以接一个范围的

shell命令
`:!date`
使用`:!!`重复命令


读取文件插入到指定行`:12r file`
还可以是运行程序插入`:12r !command`

使用`n!!fmt`可以对缓冲区当前行进行shell命令处理，在前面输入数字就是对第多少行进行输入处理并且替代当前这些行
使用`!move profram`可以对当前行到move行进行处理

`:w >> file`追加到file上

`:e file`编辑指定文件

缩写abbreviate，可以使用`:ab eg egg and god`,使用`:una`解除，使用`ab`查看

使用`:map x command`创建宏
使用`:unmap x`删除宏


## 文件
特殊文件包括`/dev/`下的硬件，硬盘之类的
`/dev/tty`终端，伪终端之类的
还有伪设备
`/dev/null`
`/dev/zero`
`/dev/random`
`/dev/urandom`

命名管道使用`mkfifo pipename`可以促成进程间通信

proc文件就是一些内核相关的文件
![|500x308](unix%20大学教程-1751374108606.webp)


挂载就是把文件系统附加到主树上使用`mount`
断开 文件系统就卸载`umount`


| 目录         | 内容                 |
| ---------- | ------------------ |
| /bin       | 放二进制文件，也就是大部分软件，工具 |
| /boot      | 存放引导文件，内核也在里面      |
| /dev       | 所有的特殊文件，包括物理设备和伪文件 |
| /etc       | 配置文件               |
| home       | 用户目录               |
| lib        | 存放程序运行时用的库         |
| /media     | 可移动介质的挂载点          |
| /mnt       | 固定介质的挂载点           |
| /opt       | 安装第三方应用的位置         |
| /proc      |                    |
| /root      | 超级用户的目录一           |
| /sbin      | 系统二进制文件            |
| /srv       | 本地服务相关的数据          |
| /tmp       | 临时文件               |
| /usr       | 辅助文件系统，存放静态数据存好多东西 |
| /var       | 存放可变数据             |
| /usr/local | 存放本地程序和文档资料之类的     |
| /usr/share | 存放静态数据，字体，文档，图标，手册 |
|            |                    |
不同文件系统间通过虚拟文件系统VFS交流文件




## 目录栈
使用`pushd dir`压入
使用`pushd +2`把对应标号的目录放
在栈顶，也就直接切换到对应目录了
`popd`弹出栈顶
`pop +n`弹出对应目录
用`dirs`查看目录栈`-l`查看完整目录路径`-v`用数字标号
`dirs -c`清空目录栈

可以使用别名简化`alias d="dirs -v` `alias p=pushd`

## ls
组合统计文件个数`ls -C | wc -l`
反向输出`-r`
递归输出`-R`
显示标注`-F`,其中可执行文件为`*`，目录为`/`，符号连接为`@`，命名管道为`|`
显示目录本身`ls -d`其中显示的时间为修改时间
显示访问时间`ls -u`
按照时间顺序排序`ls -t`还可以加上`-r`反向排序
检查文件使用`file name`

文件类型

| 指示符 | 含义             |
| --- | -------------- |
| `-` | 普通文件           |
| `d` | 目录             |
| `l` | 符号连接           |
| `b` | 特殊文件（块设备，如磁盘）  |
| `c` | 特殊设备（字符设备，如终端） |
| `p` | 命名管道           |




看文件大小`ls -s`其中使用`-h`适合人类阅读
使用`du filename`查看文件大小
使用`df -h`查看磁盘可用空间

磁盘会按照固定大小分配空间，最小可能4k


## 通配符

| 符号                       | 含义                   |
| ------------------------ | -------------------- |
| `*`                      | 匹配一个或者多个             |
| `？`                      | 匹配一个字符               |
| \[a-z]                   | 匹配其中的某个字符            |
| \[^a-z]                  | 匹配不再其中的某个字符          |
| {string1 \| string2}     | 匹配其中一个指定的字符串         |
| {string,string2,string3} | 花括号拓展，逗号间没有空格，按顺序每一个 |
## tree
只显示目录`tree -d`
显示完整路径名`tree -f`
省略缩进`tree -i`可以用来收集路径名`tree -dfi ~`
还可以限制路径深度`tree -L 2 ~`

文件管理器nautilus

## touch
使用touch修改文件的修改时间和访问时间
其中使用`-m`只修改修改时间，使用`-a`只修改访问时间。还有可以使用`touch -a -t 200812231030 file1`取代当前时间，格式为yyyymmddhhmm
可以创建空文件
可以使用`touch -c fiel1 file2 fiel3`可以不创建不存在的文件

复制`cp file1 file2 -i`新建或覆盖file2,i会询问一遍
使用`cp file1 file2 file3 dir`把多个文件复制到指定目录中
复制目录`cp -r dir1 dir2`

mv 
`-i`交互询问
`f`不问
可以把多个文件移动到目录中
也可以重命名文件和目录
可以移动并且重命名，就移动到指定目录里指定名字就可以了


## cp复制
`cp file1 file2`把文件1复制为文件2,可以创建和覆盖
`cp file.. dir`复制到其他路径
	复制目录`cp -r dir.. dir`
	

 
## rm
`-i`交互询问
`-f`强制不问
`-r`递归删除文件夹

## 权限
目录
读：读取目录
写：创建，移动，复制，删除目录条目
执行：进入目录，访问目录下的文件


权限setuid使用户拥有root权限来运行某程序，属主的执行权限显示为s

使用`id`显示自己的用户id
使用`groups id`显示id的组（没什么用）

### 文件模式
4读
2写
1执行
0无

修改权限`chmod mod file..`

新文件初始为：
不可执行文件666
可执行文件和目录777

用户掩码（user mask）为希望减去的权限
`umask 022`

粉碎文件shred file

创建文件的时候，unix会创建index node来存放文件的基本信息

使用`stat file`查看i节点信息
i节点被存在节点表。每个i节点有一个节点号，使用`ls -i`查看
文件名和i节点之间的连接称为**链接**，

### 创建链接
`ln file newname`为文件file创建硬链接，都指向同一个inode
`ln file file2  dir`为多个文件创建链接放在指定目录
基本文件命令的工作方式：
`mkdir`，创建一个目录和inode
`cp`，复制的文件覆盖原文件，那么就继承之前的链接，如果复制创建一个新文件，那么就创建一个新的inode
`mv`inode不变

#### 符号链接，软链接
相当于就是快捷方式，可以为目录创建符号链接
`ln -s dir newname`
使用`ls -l `可以看到，符号链接的目录大小

## 查找命令
### whereis
查找特定目录，大概都是些unix命令相关内容
`whereis [-bms] command`
`-b`查找可执行文件
`-m`查找手册
`s`查找源文件

### locate搜索数据库，比较快
`locate [bcirs] file`
`-r`使用正则表达式`locate -r ‘*jpg$‘`
组合使用`grep`模糊查找某些文件`locate dict | grep words`
`-c`统计个数count
`-i`忽略大小写
`-b`搜索文件名，基名

### find
`find path... test... action...`搜索路径，条件，执行操作

路径可以多个，最后会搜索整个文件树

测试
![|500x430](unix%20大学教程-1751961079815.webp)
比较重要的测试条件，
>[!note]
>使用正则表达式和一些元字符需要转译使用\或‘’
>对测试求反使用！就要转义

一些错误信息通过`2>/dev/null`来处理

![|500x191](unix%20大学教程-1751961415957.webp)

`-exec command {} \;`把输出传递给命令执行操作，每查找到一条就执行一次
使用管道传输给xargs一次性处理更高效

`xargs [-prt] [-i string] [command [argument...]]`
其中string为占位符一般为{}，command是希望执行的命令，argument为标准输入
`find . -name '*.png' | xargs echo`

使用`-i`insert插入可以把传入的标准输入多次使用，但是必须和其他命令分开`find . -type f | xargs -i mv {} {}.old`实现批量重命名
使用`-p`prompt提示，这样执行每条命令都会询问
`-t`显示生成了什么命令

xagrs十分强大，可以配合其他命令使用



## 进程
所有进程都在进程表中，每个条目处理PID还有许多其他信息，由内核调度器维护
**系统调用**就是进程需要内核执行服务的时候发送的请求，最重要的有fork,exec,wait,exit
![|500x217](unix%20大学教程-1752328153228.webp)

输出当前shell的PID`echo $$`
 shell创建新进程的过程：
 1. shell使用fork系统调用创建一个新进程
 2. 子进程使用exec系统调用变成外部程序进程
 3. 父进程shell使用wait系统调用暂停
 4. 外部程序结束，子进程使用exit系统调用通知自身

**僵进程（zombie**就是被杀死的进程，但仍然在进程表，之后唤醒父进程移除
**孤儿进程**就是父进程提前死亡的子进程，会被init进程收养

fork系统调用后会分别向父进程和子进程传递一个返回值，用来区分父进程和子进程

引导启动后内核会创建一个**空闲进程**，执行一些功能后就会分叉出**初始化进程**，init就是所有进程的祖先，有时候还会收养孤儿进程

通过键入&在末尾来使程序在后台运行
>[!后台进程注意]
>不能有从键盘读入，否则会无期限等待下去
>不能有输出到终端，否则会扰乱屏幕输出，使用`^L`刷新屏幕

`sleep interval [s|m|h|d]`延迟输出

作业控制，同时控制多个作业
![|500x418](unix%20大学教程-1752330627899.webp)

使用作业表控制整个作业流
使用`&`来运行后台作业，后台作业会显示PID和作业号，多个PID就显示最后一个程序的PID

进程使用`^Z`发送susp信号挂起进程（suspend或stop），挂起shell需要使用`suspend [-f]
使用`fg`恢复挂起的作业
显示挂起的作业`jobs [-l]`其中+是当前作业，-是前一个作业，也是队列中的下一个作业
使用`fg`，`fg %[job]`,`%[job]`将作业移至前台唯一命令可选的命令
![|500x174](unix%20大学教程-1752331449988.webp)

使用`bg [%job...]`把作业移至后台，可以在不想前台运行程序的时候，挂起程序，然后使用bg把程序移至后台运行


`ps [-aefFly] [-p pid] [-u userid]`这是UNIX选项的基本语法
`ps [sjluvx] [p pid] [U userid]`这是BSD选项的基本语法
![|500x397](unix%20大学教程-1752331811887.webp)

![|500x372](unix%20大学教程-1752331834273.webp)

使用`top`查看系统动态的
`top [-d delay] [-n count] [-p pid...]`

使用`pstree`查看进程树
`pstree [-aAcGnpu] [pid | userid]`
>[!选项说明]
>1. `-c`不要压缩重复的进程
>2. `-A`使用ASCII
>3. `-G`使用行绘制
>4. `-p`显示进程  
>5. `-n`按照PID排序
>6. 用PID或者UID可以查看对应的进程树

ps和top都是同过伪文件`proc`来访问内核的进程信息的

`kill [-9] pid...  | jobs ...`其中jobs使用%来表示
进程失控，使用其他终端来kill就可以了，使用-9强制杀死

`kill [-signal] pid.. | jobs..`可以发送信号给进程
![|500x159](unix%20大学教程-1752332875998.webp)
可以使用编号，名称，编写用`kill -l`查看


使用`nice [-n adjustment] command`调整命令的优先度，只能对非内置shell命令的独立程序，对后台程序使用0～19数字越大优先度越低
调整运行中的程序需要先挂起程序，然后使用bg移至后台，然后使用`renice nicement -p PID`


**守护进程**就是后台运行的不需要和终端连接的程序，目的是提供服务


















